@using BlazorGoogleLogin.Shared.Models.present.toAdd
@using BlazorGoogleLogin.Shared.Models.present.toShow
@using BlazorGoogleLogin.Shared.Models.present.toEdit
@using System;
@using System.Globalization;
@inject HttpClient Http

@if (isLoadComplete)
{
    <div class="overlay">
        @{
            string displayStyle = (transDisplay == false) ? "none" : "flex";
        }
        <div class="outerTransOverlay" style="display:@displayStyle">
            <div class="innerTransOverlay">
                <button class="modal-close-btn" @onclick="transOverlayControl"><img src="./css/images/close x.svg" /></button>
                <div class="expAndTitle">

                    @if (isItAnewTrans)
                    {
                        <div class="outerTitleAndDivider">
                            <div class="outerTitle">
                                <span>@overlayTitle:  </span>
                                <span>@subCategoryTitle</span>

                            </div>
                            <div class="divider"> </div>
                        </div>
                    }
                    else
                    {
                        <div class="outerTitleAndDivider">
                            <div class="outerTitle">
                                <span>@overlayTitle:</span>
                                <span>@ogTransaction.transTitle</span>

                            </div>
                            <div class="divider"> </div>
                        </div>
                    }

                    <div>

                        <div @onclick="@(()=>expBubbleToolTip("Trans"))"><img src="./css/images/q-with-shadow.svg" style="height: 3rem;" /></div>
                        @if (topExpBubbleOpen)
                        {

                            <TutorialOverlay elementID="Trans" closeOverlay="closeExpOverlay"></TutorialOverlay>
                        }

                    </div>

                </div>

                <div class="accordionAndTransDetailsWrap">

                    <div class="transDetailsAccordion" @onclick="manageDropDown">
                        @if (categoryTypeIndicator)
                        {
                            nameInputPlaceholder = "שם ההכנסה שלי";
                            <span class="accordionText">ההכנסה שלי</span>
                        }
                        else
                        {
                            nameInputPlaceholder = "שם ההוצאה שלי";
                            <span class="accordionText">ההוצאה שלי</span>
                        }

                        <span class="accordionPoly"><img src="./css/images/arrow3.svg" /></span>
                    </div>

                    @if (isTopDropDownOpen)
                    {

                        <div class="outerDetails">
                            <div class="innerPaddingDiv">
                                <div class="outerTitleAndDate">
                                    <div class="outerTitleAndCounter">
                                        <div class="input-container">

                                            @*   ---- TRANS TITLE & COUNTER  ----*@
                                            <input class="titleBox" type="text" @bind="titleInput" @oninput="TransTitleLengthCounter" maxlength="18" minlength="2" placeholder="@nameInputPlaceholder" />
                                            <div class="counter">
                                                @if (titleInput.Length > 0 && titleInput.Length < 19)
                                                {
                                                    <span>@titleInput.Length/18</span>
                                                }
                                                else if (titleInput.Length <= 0)
                                                {
                                                    <span>0/18</span>
                                                }
                                            </div>
                                        </div>
                                        @*   ---- TRANS DATE  ----*@
                                    </div>
                                    <input type="date" @bind="newTransaction.transDate" min="@(DateTime.Today.ToString("yyyy-MM-dd"))" class="custom-date-input" />
                                </div>
                                <div>
                                    @if (titleInput.Length < 2)
                                    {
                                        if (isTyped)
                                        {
                                            if (categoryTypeIndicator)
                                            {
                                                <span style="color:#F95050">שם ההכנסה צריך להיות בין 2-18 תווים.</span>
                                            }
                                            else
                                            {
                                                <span style="color:#F95050">שם ההוצאה צריך להיות בין 2-18 תווים.</span>
                                            }
                                        }
                                    }
                                </div>

                                @*   ---- TRANS SUM  ----*@
                                <div class="outerTitleAndDateAndName">
                                    @if (categoryTypeIndicator)
                                    {
                                        <span class="titleName">סכום ההכנסה</span>
                                    }
                                    else
                                    {
                                        <span class="titleName">סכום ההוצאה</span>
                                    }

                                    <div class="outerBudget">
                                        <input class="budgetBox" id="description" type="number" @bind="newTransaction.transValue" @oninput="transAmount" />
                                        <span class="currency-symbol">₪</span>
                                        <div class="lineBetween"></div>
                                        <div>
                                            @if (newTransaction.transValue <= 0)
                                            {
                                                if (categoryTypeIndicator)
                                                {
                                                    if (isTransSumTyped)
                                                    {
                                                        <span style="color:#F95050">סך ההכנסה לא תקין.</span>
                                                    }

                                                }
                                                else
                                                {
                                                    if (isTransSumTyped)
                                                    {
                                                        <span style="color:#F95050">סך ההוצאה לא תקין.</span>
                                                    }

                                                }

                                            }
                                        </div>
                                    </div>

                                </div>



                                <div class="outerReBtn @disReClass">

                                    <div class="outerReBtn">
                                        <button class="repeatedBtn" @onclick=@(async () => await repeatingTransOverlay())>@repeatedBtnTitle <img src="./css/images/repeat icon.svg" /></button>
                                        @if (newTransaction.fixedMonthly.HasValue && newTransaction.fixedMonthly == true)
                                        {
                                            isRepeatedTrans = true;
                                            if (categoryTypeIndicator)
                                            {
                                                //repeatedBtnTitle = "עריכת ההכנסה החוזרת";
                                                <button class="cancleRepeatedBtn" @onclick="undoFixedMonthly">ביטול הכנסה חוזרת</button>
                                            }
                                            else
                                            {
                                                //repeatedBtnTitle = "עריכת ההוצאה החוזרת";
                                                <button class="cancleRepeatedBtn" @onclick="undoFixedMonthly">ביטול הוצאה חוזרת</button>
                                            }
                                        }
                                        else
                                        {
                                            isRepeatedTrans = false;
                                            if (categoryTypeIndicator)
                                            {
                                                repeatedBtnTitle = "הגדרת ההכנסה כחוזרת";

                                            }
                                            else
                                            {
                                                repeatedBtnTitle = "הגדרת ההוצאה כחוזרת";
                                            }
                                        }

                                    </div>
                                </div>




                                <div class="outerTitleAndDateAndName @disSpClass">

                                    @if (splitPayment)
                                    {

                                        <div class="splitToggle">
                                            @if (categoryTypeIndicator)
                                            {
                                                <span class="titleName">ההכנסה בתשלומים?</span>
                                            }
                                            else
                                            {
                                                <span class="titleName">ההוצאה בתשלומים?</span>
                                            }

                                            <label class="switchSpendings">
                                                <span class="knobYes"></span>
                                                <input type="checkbox" class="hidden-checkbox" @bind="splitPayment">
                                                <span class="slider"></span>
                                            </label>
                                        </div>
                                        <div class="outerDropAndAv">
                                            <select class="splitDrop" @bind="selectedNumber">

                                                <option value="" disabled selected>מספר תשלומים</option>
                                                @for (int i = 2; i <= 12; i++)
                                                {

                                                    <option value="@i">@i תשלומים</option>
                                                }
                                            </select>

                                            @if (isItAnewTrans)
                                            {


                                                <div class="outerSum">
                                                    <div>
                                                        סכום כל תשלום:
                                                    </div>
                                                    <div>
                                                        בממוצע
                                                        <span style="font-weight:700">
                                                            @(Math.Round((newTransaction.transValue / selectedNumber), 2)
                                                                ) ₪
                                                        </span>

                                                    </div>


                                                </div>
                                            }
                                            else
                                            {


                                                
                                                    if (newTransaction.transValue != sumPreSplit)
                                                    {
                                                        sumPreSplit = newTransaction.transValue;
                                                    }
                                                    <div class="outerSum">
                                                        <div>
                                                            סכום כל תשלום:
                                                        </div>
                                                        <div>
                                                            בממוצע
                                                            <span style="font-weight:700">
                                                                @(
                                                                    Math.Round((sumPreSplit / selectedNumber), 2)
                                                                    ) ₪
                                                            </span>

                                                        </div>


                                                    </div>
                                                
                                            }
                                        </div>

                                    }
                                    else
                                    {

                                        secondSplit = true;
                                        <div class="splitToggle">
                                            @if (categoryTypeIndicator)
                                            {
                                                <span class="titleName">ההכנסה בתשלומים?</span>
                                            }
                                            else
                                            {
                                                <span class="titleName">ההוצאה בתשלומים?</span>
                                            }
                                            <label class="switch">
                                                <span class="knob"></span>
                                                <input type="checkbox" class="hidden-checkbox" @bind="splitPayment">
                                                <span class="slider"></span>
                                            </label>
                                        </div>
                                    }
                                    @{
                                        newTransaction.splitPayment = splitPayment;
                                        if (splitPayment == false)
                                        {

                                            selectedNumber = 1;
                                        }

                                    }


                                </div>




                                @*   ---- PAYMENT METHOD ----*@
                                <div class="outerTitleAndDateAndName">
                                    <div class="outerPaymentMethod">
                                        <span class="titleName">אמצעי תשלום</span>

                                        @if (newTransaction.valueType == null)
                                        {
                                            newTransaction.valueType = "מזומן";
                                        }
                                        <select class="splitDrop" @bind="newTransaction.valueType">

                                            <option value="מזומן">מזומן</option>
                                            <option value="אשראי">אשראי</option>
                                            <option value="ביט/פייבוקס">ביט/פייבוקס</option>
                                            <option value="אחר">אחר</option>

                                        </select>
                                    </div>
                                    <div>
                                        @if (newTransaction.valueType == "" || newTransaction.valueType == null)
                                        {
                                            <span style="color:#F95050">לא נבחר אמצעי תשלום.</span>
                                        }
                                    </div>
                                </div>


                                @if (newTransaction.fixedMonthly == true) // עריכת הוצאה חוזרת
                                {
                                    if (returningTrans) //opens the repeated trans overlay
                                    {
                                        <div class="outerRepetedTrans" style="@hiddenReOverlay">
                                            <div class="innerTransOverlay">
                                                <button class="modal-close-btn" @onclick="backToTrans"><img src="./css/images/back-repeated.svg" /></button>
                                                @*overlay instructions:*@
                                                @if (categoryTypeIndicator)
                                                {
                                                    <h4>הגדרת '@newTransaction.transTitle' כהכנסה חוזרת על עצמה</h4>
                                                    <div class="reText">במידה וההכנסה חוזרת בסכום שונה, יש להזין את הסכום הרצוי. בחודש בו אינה חוזרת, יש להזין 0.</div>
                                                }
                                                else
                                                {
                                                    <h4>הגדרת '@newTransaction.transTitle' כהוצאה חוזרת על עצמה</h4>
                                                    <div class="reText">במידה וההוצאה חוזרת בסכום שונה, יש להזין את הסכום הרצוי. בחודש בו אינה חוזרת, יש להזין 0.</div>
                                                }

                                                <div class="outerMonths">
                                                    @if (resetMonthValues == false)
                                                    {
                                                        isResetBtnClicked = false;
                                                        foreach (string month in months)
                                                        {
                                                            <div class="monthValueInput">
                                                                <label>@GetHebrewMonthName(month)</label>

                                                                @{
                                                                    // Attempt to find a matching transaction for the month
                                                                    var matchingTrans = reapeatedTransValuesList.FirstOrDefault(trans => trans.transDate.ToString("MMMM") == month);


                                                                    <div class="monthDivider"></div>
                                                                    // Determine the value to display in the input
                                                                    string inputValue = "";

                                                                    if (matchingTrans == null)
                                                                    {
                                                                        var matchingTinPage = potentialFixedChildren.FirstOrDefault(trans => trans.transDate.ToString("MMMM") == month);
                                                                        if (matchingTinPage != null)
                                                                        {
                                                                            inputValue = matchingTinPage.transValue.ToString();
                                                                        }
                                                                        else
                                                                        {
                                                                            inputValue = "0";
                                                                        }
                                                                    }
                                                                    else
                                                                    {
                                                                        inputValue = matchingTrans.transValue.ToString();
                                                                    }
                                                                    //inputValue = matchingTrans != null ? matchingTrans.transValue.ToString() : "0";

                                                                }

                                                                @*   @if (GetCurrentMonth() == month)*@
                                                                @if (newTransaction.transDate.ToString("MMMM") == month)
                                                                {
                                                                    inputValue = newTransaction.transValue.ToString();
                                                                    <div class="thisOuterValue">
                                                                        <input id="this" class="thisMonth" type="text" value="@inputValue"
                                                   @oninput="eventArgs => HandleRepeatedInput(eventArgs, month, matchingTrans)" />
                                                                        <span class="ShekelSign">₪</span>
                                                                    </div>

                                                                }
                                                                else
                                                                {
                                                                    <div class="outerValue">
                                                                        <input class="month" type="text" disabled="@IsPastMonth(month)" value="@inputValue"
                                                   @oninput="eventArgs => HandleRepeatedInput(eventArgs, month, matchingTrans)" />
                                                                        <span class="ShekelSign">₪</span>
                                                                    </div>
                                                                }

                                                            </div>
                                                        }
                                                    }
                                                    else //the user pressed the reset month values button
                                                    {
                                                        isResetBtnClicked = true;
                                                        isValueTyped = false; //means no value written last is a number

                                                        @if (!isValueTypedAfterReset)
                                                        {
                                                            foreach (TransactionToAdd tToCheck in fixedTransChildrenToAdd)
                                                            {
                                                                tToCheck.transValue = 0;
                                                            }
                                                        }

                                                        foreach (string month in months)
                                                        {
                                                            <div class="monthValueInput">
                                                                <label>@GetHebrewMonthName(month)</label>
                                                                @*@if (GetCurrentMonth() != month)*@
                                                                @if (newTransaction.transDate.ToString("MMMM") != month)
                                                                {

                                                                    <div class="monthDivider"></div>
                                                                    <div class="outerValue">
                                                                        <input class="month" type="text"
                                                   disabled="@IsPastMonth(month)" value="0" @oninput="eventArgs => HandleInput(eventArgs, month)" />
                                                                        <span class="ShekelSign">₪</span>
                                                                    </div>

                                                                }
                                                                else
                                                                {
                                                                    <div class="monthDivider"></div>
                                                                    <div class="thisOuterValue">

                                                                        <input class="thisMonth" type="text"
                                                   value="@GetDefaultValue(month)" @oninput="eventArgs => HandleInput(eventArgs, month)" />
                                                                        <span class="ShekelSign">₪</span>

                                                                    </div>
                                                                }


                                                            </div>
                                                        }
                                                    }
                                                </div>
                                                <div class="outerSaveBtns">
                                                    @if (isResetBtnClicked && !isValueTypedAfterReset) //means there was a reset but no values were re-added
                                                    {

                                                        <button class="primery-button" disabled>שמירה וחזרה</button>
                                                    }
                                                    else if (isValueTyped && isResetBtnClicked)  //means there was a reset but no valid number values were re-added
                                                    {
                                                        <button class="primery-button" disabled>שמירה וחזרה</button>
                                                    }
                                                    else if (isValueTypedAfterReset) //means valid values were added after the reset
                                                    {
                                                        <button class="primery-button" @onclick="backToTrans">שמירה וחזרה</button>
                                                    }
                                                    else //means valid values were added, no reset done
                                                    {
                                                        <button class="primery-button" @onclick="backToTrans">שמירה וחזרה</button>
                                                    }
                                                    <button class="secondery-button" @onclick="() => resetMonthValues = !resetMonthValues">@textOnResetBtn</button>

                                                </div>
                                            </div>
                                        </div>
                                    }
                                }
                                else //trans isn't initially fixed
                                {

                                    <div class="outerRepetedTrans" style="@hiddenReOverlay">
                                        <div class="innerTransOverlay">
                                            @if (returningTrans)
                                            {
                                                <button class="modal-close-btn" @onclick="backToTrans"><img src="./css/images/back-repeated.svg" /></button>
                                                @*overlay instructions:*@
                                                @if (categoryTypeIndicator)
                                                {
                                                    <h4>הגדרת '@newTransaction.transTitle' כהכנסה חוזרת על עצמה</h4>
                                                    <div class="reText">במידה וההכנסה חוזרת בסכום שונה, יש להזין את הסכום הרצוי. בחודש בו אינה חוזרת, יש להזין 0.</div>
                                                }
                                                else
                                                {
                                                    <h4>הגדרת '@newTransaction.transTitle' כהוצאה חוזרת על עצמה</h4>
                                                    <div class="reText">במידה וההוצאה חוזרת בסכום שונה, יש להזין את הסכום הרצוי. בחודש בו אינה חוזרת, יש להזין 0.</div>
                                                }

                                                <div class="outerMonths">
                                                    @if (resetMonthValues == false)
                                                    {
                                                        isResetBtnClicked = false;
                                                        //checking if the list was reset:
                                                        bool childrenWereReset = fixedTransChildrenToAdd.All(t => t.transValue == 0);
                                                        if (childrenWereReset)
                                                        {
                                                            foreach (TransactionToAdd tChild in fixedTransChildrenToAdd)
                                                            {
                                                                var matchingChild = potentialFixedChildren.FirstOrDefault(p => p.transDate == tChild.transDate);
                                                                if (matchingChild != null)
                                                                {
                                                                    int indexOfMatch = potentialFixedChildren.IndexOf(matchingChild);
                                                                    tChild.transValue = potentialFixedChildren[indexOfMatch].transValue;
                                                                }
                                                            }
                                                        }

                                                        foreach (string month in months)
                                                        {
                                                            string defValue = GetDefaultValue(month);

                                                            <div class="monthValueInput">

                                                                @* @if (GetCurrentMonth() == month)*@
                                                                @if (newTransaction.transDate.ToString("MMMM") == month)
                                                                {
                                                                    <label>@GetHebrewMonthName(month)</label>
                                                                    <div class="monthDivider"></div>
                                                                    <div class="thisOuterValue">
                                                                        <input class="thisMonth" type="text"
                                                   value="@defValue" @oninput="eventArgs => HandleInput(eventArgs, month)" />
                                                                        <span class="ShekelSign">₪</span>
                                                                    </div>
                                                                }
                                                                else
                                                                {
                                                                    <label>@GetHebrewMonthName(month)</label>
                                                                    <div class="monthDivider"></div>
                                                                    <div class="outerValue">
                                                                        <input class="months" type="text"
                                                   disabled="@IsPastMonth(month)" value="@defValue" @oninput="eventArgs => HandleInput(eventArgs, month)" />
                                                                        <span class="ShekelSign">₪</span>
                                                                    </div>
                                                                }

                                                            </div>
                                                        }

                                                    }
                                                    else
                                                    {
                                                        isResetBtnClicked = true;
                                                        isValueTyped = false;

                                                        if (!isValueTypedAfterReset)
                                                        {
                                                            foreach (TransactionToAdd tToCheck in fixedTransChildrenToAdd)
                                                            {
                                                                tToCheck.transValue = 0;
                                                            }
                                                        }

                                                        foreach (string month in months)
                                                        {
                                                            <div class="monthValueInput">
                                                                <label>@GetHebrewMonthName(month)</label>
                                                                <div class="monthDivider"></div>
                                                                <div class="outerValue">

                                                                    @if (newTransaction.transDate.ToString("MMMM") != month)
                                                                    {
                                                                        <input class="months" type="text"
                                                   disabled="@IsPastMonth(month)" value="0" @oninput="eventArgs => HandleInput(eventArgs, month)" />
                                                                        <span class="ShekelSign">₪</span>
                                                                    }
                                                                    else
                                                                    {
                                                                        <div class="thisOuterValue">
                                                                            <input class="thisMonth" type="text"
                                                       value="@newTransaction.transValue.ToString()" @oninput="eventArgs => HandleInput(eventArgs, month)" />
                                                                            <span class="ShekelSign">₪</span>
                                                                        </div>
                                                                    }
                                                                </div>
                                                            </div>
                                                        }
                                                    }

                                                </div>
                                                <div class="outerSaveBtns">
                                                    @if (isResetBtnClicked && !isValueTypedAfterReset) //means there was a reset but no values were re-added
                                                    {

                                                        <button class="primery-button" disabled>שמירה וחזרה</button>
                                                    }
                                                    else if (isValueTyped && isResetBtnClicked) //means there was a reset but no valid number values were re-added
                                                    {
                                                        <button class="primery-button" disabled>שמירה וחזרה</button>
                                                    }
                                                    else if (isValueTypedAfterReset) //means valid values were added after the reset
                                                    {
                                                        <button class="primery-button" @onclick="backToTrans">שמירה וחזרה</button>
                                                    }
                                                    else //means valid values were added, no reset done
                                                    {
                                                        <button class="primery-button" @onclick="backToTrans">שמירה וחזרה</button>
                                                    }

                                                    <button class="secondery-button" @onclick="() => resetMonthValues = !resetMonthValues">@textOnResetBtn</button>
                                                </div>

                                            }
                                        </div>
                                    </div>
                                }
                            </div>
                        </div>
                    }

                </div>


                <div>
                    @*bottom dropdown*@

                    <div class="transDetailsAccordion" @onclick="@(async () => await getAllUserTags())">

                        <span class="accordionText">הגדרות מתקדמות</span>
                        <span class="accordionPoly"><img src="./css/images/arrow3.svg" /></span>
                    </div>


                    @if (isButtomDropDownOpen)
                    {
                        <div class="outerDetails">
                            <div class="innerPaddingDiv">
                                <div class="outerTitleAndDateAndName">
                                    <div id="tagTitleAndExp">
                                        <span class="titleName">תגית</span>
                                        <img src="./css/images/q-with-shadow.svg" style="height: 3rem;" @onclick="@(()=>expBubbleToolTip("TransTag"))" />
                                        @if (bottomExpBubbleOpen)
                                        {
                                            <TutorialOverlay elementID="TransTag" closeOverlay="closeExpOverlay"></TutorialOverlay>
                                        }
                                    </div>


                                    @if (chosenTag.id > 0) //existing tag
                                    {
                                        <div class="addTagBtn">

                                            <img src="./css/images/after-tag.svg" />
                                            <span class="tag tagLabel" style="background-color:@chosenTag.tagColor">@chosenTag.tagTitle</span>

                                        </div>
                                    }

                                    @*   ---- TAG GALLERY ----*@
                                    <div class="outerGalleryAndNav">
                                        <div class="outerGallery">
                                            <button class="createTagBtn" @onclick="tagCreationOverlay">תגית חדשה</button>
                                            @foreach (var tag in GetCurrentPageTags())
                                            {
                                                Console.WriteLine(tag);
                                                var fontWeight = (chosenTag == tag) ? "font-weight: 600;" : "";
                                                <button class="tag"
                                            @onclick="(() => ChooseTagForTrans(tag))"
                                            style="background-color:@tag.tagColor; @fontWeight">
                                                    @tag.tagTitle
                                                </button>
                                            }

                                        </div>
                                        <div class="outerBtnAndDots">
                                            <button class="galleryArrow @disBtnStyle" @onclick="PreviousPage"><img src="./css/images/arrow-back.svg" /></button>
                                            <div class="pageDots">
                                                @for (int i = 0; i < totalPages; i++)
                                                {
                                                    <span class="dot @(i == currentPage ? "active" : "")"></span>
                                                }
                                            </div>
                                            <button class="galleryArrow @disNextBtnStyle" @onclick="NextPage"><img src="./css/images/arrow-next.svg" /></button>

                                        </div>
                                    </div>

                                </div>

                                @*   ---- DESCRIPTION TEXTBOX ----*@
                                <div class="outerTitleAndDateAndName">
                                    <span class="titleName">פירוט:</span>
                                    <textarea class="description" @bind="descriptionInput" maxlength="60" @oninput="TransDescLengthCounter"></textarea>
                                    @if (descLength > 0)
                                    {
                                        <span class="descSpan">@descLength/60</span>
                                    }
                                    else
                                    {
                                        <span class="descSpan">0/60</span>
                                    }
                                </div>

                            </div>
                        </div>

                    }

                </div>
                @*---- SAVE BUTTONS ----*@
                @if (isItAnewTrans)
                {
                    if (titleInput.Length >= 2 && titleInput.Length < 19 && newTransaction.transValue > 0 && newTransaction.valueType != null)
                    {
                        <div class="outerSaveBtns">
                            @if (categoryTypeIndicator)
                            {
                                <button class="primery-button" @onclick="saveAndRepeatTransactions">שמירה והכנסה נוספת</button>
                            }
                            else
                            {
                                <button class="primery-button" @onclick="saveAndRepeatTransactions">שמירה והוצאה נוספת</button>
                            }


                            <button class="secondery-button" @onclick="saveAndEndTransactions">שמירה וסיום</button>
                        </div>
                    }
                    else
                    {
                        <div class="outerSaveBtns">
                            @if (categoryTypeIndicator)
                            {
                                <button class="primery-button" @onclick="saveAndRepeatTransactions" disabled>שמירה והכנסה נוספת</button>
                            }
                            else
                            {
                                <button class="primery-button" @onclick="saveAndRepeatTransactions" disabled>שמירה והוצאה נוספת</button>
                            }
                            <button class="secondery-button" @onclick="saveAndEndTransactions" disabled>שמירה וסיום</button>

                        </div>
                    }

                }
                else
                {
                    if (titleInput.Length >= 2 && titleInput.Length < 19 && newTransaction.transValue > 0 && newTransaction.transDate != null && newTransaction.valueType != null)
                    {
                        <div class="outerSaveBtns">
                            <button class="primery-button" @onclick="updateExistingTrans">שמירה וסיום</button>
                        </div>
                    }
                    else
                    {
                        <div class="outerSaveBtns">
                            <button class="primery-button" @onclick="updateExistingTrans" disabled>שמירה וסיום</button>

                        </div>
                    }

                }
            </div>
        </div>
    </div>

    @*---- OVERDRAFT POPUP ----*@
    @if (overdraftDetected && closeOverdraftOpts.Count > 1)
    {

        <div class="overlay">
            <div class="outerOverdraft">
                <div class="overdraftWindow" id="presentOnboarding5">
                    <div class="expDivAndTitle">
                        <div class="expDiv">

                            <div class="expBtn" @onclick="@(()=>expBubbleToolTip("ODwithSubCats"))"><img src="./css/images/q-with-shadow.svg" /></div>
                            @if (odExpBubble)
                            {

                                <TutorialOverlay elementID="@elementToExp" closeOverlay="closeExpOverlay"></TutorialOverlay>
                            }

                        </div>

                        <h3 class="titleText">חרגת...</h3>
                    </div>
                    <div class="outerText">

                        <div>-נראה שהוצאת ב @subCategoryTitle @Math.Round(closeOverdraftOpts[closeOverdraftOpts.Count-1].remainingBudget)  ₪ </div>
                        <div>שזה <span><b>@currentGap ₪</b></span> יותר </div>
                        <div>מהתקציב שהגדרת: @closeOverdraftOpts[closeOverdraftOpts.Count-1].monthlyPlannedBudget ₪ </div>
                        <div>כדאי להגדיל את התקציב.</div>
                        <div><b>הסכום שאני רוצה להעביר:</b></div>
                        <div class="outerCurrentGap">
                            <input class="currentGap" type="number" @oninput="OverdraftBudgetSumInput" min="@currentGap" maxlength="6" minlength="1" value="@currentGap" />
                            <span class="currency-symbolOverDraft">₪</span>
                            <div class="lineBetweenOverdraft"></div>
                        </div>

                        <div>מאיזו תת קטגוריה יועבר הסכום?</div>
                    </div>
                    <div class="outerTranferTable">

                        <div class="outerFromSubCats">
                            <span style="font-weight:700;">העברה מ:</span>
                            <div class="outerDropAndOptions">
                                <div class="outerDropAndPoly" @onclick="()=>openSubCatsOptions =! openSubCatsOptions">
                                    <div class="subCatsDrop">
                                        <span>@chosenSubCategory.subCategoryTitle</span>
                                        <span class="accordionPoly"><img style="width:7vw;" src="./css/images/arrow3.svg" /></span>
                                    </div>

                                </div>
                                @if (openSubCatsOptions)
                                {
                                    <div class="subCatsDropDown">
                                        @foreach (OverBudgetToShow subcategoryOpt in closeOverdraftOpts)
                                        {
                                            @if (subcategoryOpt.id != subCategoryIDTOGet)
                                            {
                                                <div @onclick="()=>HandleChange(subcategoryOpt)">
                                                    @subcategoryOpt.subCategoryTitle
                                                </div>
                                            }
                                        }
                                    </div>

                                }
                            </div>
                            <div class="outerBudgets">
                                <div class="outerBudgetTitle">
                                    <div style="font-weight: 600;">תקציב:</div>
                                    <div class="titleDivder"></div>
                                </div>
                                @if (string.IsNullOrEmpty(chosenSubCategory.subCategoryTitle))
                                {
                                    <div>
                                        נוכחי: 0 <span>₪</span>

                                    </div>
                                    <div>
                                        עתידי: 0 <span>₪</span>
                                    </div>
                                }
                                else
                                {
                                    <div>
                                        נוכחי: @chosenSubCategory.monthlyPlannedBudget
                                        <span>₪</span>
                                    </div>
                                    <div>
                                        עתידי: @(
                                     chosenSubCategory.monthlyPlannedBudget - budgetSumToMove
                                     )
                                        <span>₪</span>
                                    </div>
                                }
                            </div>

                        </div>
                        <div class="outerToSubCat">

                            <span style="font-weight:700;">העברה ל:</span>
                            <div class="outerDropAndOptions">
                                <div class="outerDropAndPoly">
                                    <div class="subCatsDrop" style="justify-content: center;">
                                        @(
                                            overDraftSubCategory.subCategoryTitle = closeOverdraftOpts[closeOverdraftOpts.Count - 1].subCategoryTitle
                                            )

                                    </div>

                                </div>
                            </div>

                            <div class="outerBudgets">
                                <div class="outerBudgetTitle">
                                    <div style="font-weight: 600;">תקציב:</div>
                                    <div class="titleDivder"></div>
                                </div>
                                @if (string.IsNullOrEmpty(chosenSubCategory.subCategoryTitle))
                                {
                                    <div>
                                        נוכחי: @(
                                     closeOverdraftOpts[closeOverdraftOpts.Count - 1].monthlyPlannedBudget)
                                        <span>₪</span>
                                    </div>
                                    <div>
                                        עתידי: 0 <span>₪</span>
                                    </div>
                                }
                                else
                                {
                                    <div>
                                        נוכחי: @(
                                     closeOverdraftOpts[closeOverdraftOpts.Count - 1].monthlyPlannedBudget)
                                        <span>₪</span>
                                    </div>
                                    <div>
                                        עתידי: @(
                                     closeOverdraftOpts[closeOverdraftOpts.Count - 1].monthlyPlannedBudget + budgetSumToMove)
                                        <span>₪</span>
                                    </div>

                                }
                            </div>

                        </div>

                    </div>
                    <div class="outerBtns">

                        @if (chosenSubCategory == null)
                        {
                            <button class="primery-buttonOverDraft" @onclick="manageBudgetsToTranfer" disabled>העברה</button>
                        }
                        else if (budgetSumToMove > chosenSubCategory.remainingBudget)
                        {
                            <button class="primery-buttonOverDraft" @onclick="manageBudgetsToTranfer" disabled>העברה</button>
                        }
                        else
                        {
                            <button class="primery-buttonOverDraft" @onclick="manageBudgetsToTranfer">העברה</button>
                        }
                        <button class="thirdBtn" @onclick="@(async () => await closeOverdraftWindow())">אטפל בהמשך</button>
                    </div>

                </div>
            </div>
        </div>
    }
    else if (overdraftDetected && closeOverdraftOpts.Count == 1 && closeOverdraftOpts[closeOverdraftOpts.Count - 1].id == subCategoryIDTOGet)
    {
        <div class="overlay">
            <div class="outerOverdraft">
                <div class="overdraftWindow">

                    <div class="outerCloseBtn">
                        <button class="modal-close-btn" @onclick="@(async () => await closeOverdraftWindow())"><img src="./css/images/close x.svg" /></button>
                    </div>
                    <div class="outerText">
                        <div class="expDivAndTitle">
                            <div class="expDiv">

                                <div class="expBtn" @onclick="@(()=>expBubbleToolTip("ODwithNoSubCats"))"><img src="./css/images/q-with-shadow.svg" /></div>
                                @if (odExpBubble)
                                {

                                    <TutorialOverlay elementID="@elementToExp" closeOverlay="closeExpOverlay"></TutorialOverlay>
                                }

                            </div>

                            <h3 class="titleText">חרגת...</h3>
                        </div>

                        <div>
                            אין תתי קטגוריות בעלות תקציב
                            פנוי להעברה.

                        </div>
                        <div>
                            <span><b>טיפ מאיתנו-</b></span>
                            לקראת החודש הבא,
                            כדאי להעריך מחדש את התקציב של
                            תתי הקטגוריות השונות.
                        </div>


                        <div class="outerBtns">
                            <img style="height: 31vh;" src="./css/images/no-overdraft-options.svg" />
                        </div>
                    </div>

                </div>
            </div>
        </div>
    }


}
@*---- CREATE TAG POPUP ----*@
@if (createTagOverlay)
{

    <div class="outerTransOverlay">
        <div class="megaOuterLay">
            <div class="outerLay">
                <div class="BgOverlay">
                    <div class="AddTagoverlay">
                        <div class="paddingDiv">
                            <div class="outerTitleAndIcon">
                                <button class="closeOverlay" @onclick="tagCreationOverlay"><img src="./css/images/close x.svg" /></button>
                                <h3 class="tagOVtitleName" style="font-size: 1.2rem;">יצירת תגית</h3>
                            </div>
                            <div class="outerTitleAndCounter">
                                <div class="tagTitleInput">
                                    <div>שם התגית:</div>
                                    <input type="text" class="catTitle" @bind="@currentTagName" @oninput="tagTitleLengthCheck" maxlength="8" minlength="2" />
                                    <div class="tagTitleCounter">
                                        @if (tagNameLength > 0 && tagNameLength < 9)
                                        {
                                            <span>@tagNameLength/8</span>
                                        }
                                        else if (tagNameLength < 1)
                                        {
                                            <span>0/8</span>
                                        }

                                    </div>
                                </div>
                                <div>
                                    @if (currentTagName == null || currentTagName == "")
                                    {
                                        if (emptyTagName)
                                        {
                                            <span style="color:#F95050">שם התגית צריך להיות בין 2-18 תווים</span>
                                        }

                                    }
                                </div>
                            </div>

                            <div class="outerNameAndColor">
                                <div>צבע התגית:</div>
                                <div class="outerColors">

                                    <div class="colorsContainer">
                                        <div class="colorsRow">

                                            @foreach (var color in new[] { "#F4B367", "#AEA2F9", "#F467AB", "#F47867", "#6775F4", "#8DE4BF" })
                                            {

                                                <div id="@(color)" class="@(selectedClass == color ? "color-selected" : "")">
                                                    <input style="opacity:0;" type="radio" name="categoryColors" value="@color"
                                                   @onclick="() => UpdateTagColor(color)" />

                                                </div>
                                            }
                                        </div>
                                        <div class="colorsRow">
                                            @foreach (var color in new[] { "#67CAF4", "#FCE884", "#F9D3C2", "#09AE73", "#8C8B8B", "#DADADA" })
                                            {
                                                <div id="@(color)" class="@(selectedClass == color ? "color-selected" : "")">
                                                    <input style="opacity:0;" type="radio" name="categoryColors" value="@color"
                                                   @onclick="() => UpdateTagColor(color)" />

                                                </div>
                                            }
                                        </div>
                                    </div>
                                </div>
                                <br />
                            </div>

                            <div class="outerSaveBtns">
                                @if (tagNameLength > 0 && tagNameLength < 9)
                                {
                                    <button class="primery-button" @onclick="@(async ()=> await tagCreation())">שמירה וחזרה</button>
                                }
                                else
                                {
                                    <button class="primery-button" @onclick="@(async ()=> await tagCreation())" style="opacity:60%" disabled>שמירה וסיום</button>
                                }
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
}





@code {

    [Parameter]
    public int userID { get; set; }

    [Parameter]
    public string subCategoryTitle { get; set; }

    [Parameter]
    public int subCategoryIDTOGet { get; set; }

    [Parameter]
    public EventCallback<List<OverDraftBudgetToEdit>> gapsToUpdateBudgets { get; set; }

    [Parameter]
    public EventCallback<bool> isTransactionOverlayOpen { get; set; }

    /// <summary>
    /// adds the trans sum to the subcategory component total spendings
    /// </summary>
    [Parameter]
    public EventCallback<double> addTransactionToTotal { get; set; }

    [Parameter]
    public int transIDtoEdit { get; set; }

    [Parameter]
    public EventCallback<TransactionOverviewToShow> addTransactionAfterEdit { get; set; }

    [Parameter]
    public EventCallback<bool> overdraftNotTreated { get; set; }

    [Parameter]
    public EventCallback closeAddTransAfterOverdraft { get; set; }

    [Parameter]
    public EventCallback<List<int>> SplitPaymentWithIndex { get; set; }

    [Parameter]
    public bool categoryTypeIndicator { get; set; } //will indicate if this is an expense or income subcategory

    [Parameter]
    public string userStreakStatus { get; set; }

    [Parameter]
    public EventCallback<string?> updatedStreak { get; set; }




    int userStartMonthDay = 0;
    TransactionToAdd newTransaction = new TransactionToAdd(); //if it's a new transaction
    TransactionToEdit ogTransaction = new TransactionToEdit(); //if it's an existing transaction

    List<OverBudgetToShow> closeOverdraftOpts = new List<OverBudgetToShow>();
    List<OverDraftBudgetToEdit> budgetToUpdate = new List<OverDraftBudgetToEdit>();
    List<TagsToShow> allUserTags = new List<TagsToShow>();




    TagsToShow chosenTag = new TagsToShow();
    OverBudgetToShow chosenSubCategory = new OverBudgetToShow();
    OverBudgetToShow overDraftSubCategory = new OverBudgetToShow();
    OverDraftBudgetToEdit subCategoryBudgetToUpdate = new OverDraftBudgetToEdit();
    TransactionOverviewToShow editedTransaction = new TransactionOverviewToShow();

    private DateTime? selectedDate = DateTime.Today; // Initialize selectedDate to today
    private bool isItAnewTrans = false;
    //public bool isTagClicked = false;
    public bool overdraftDetected;
    /// <summary>
    /// controls the disabled state of fixedMonthly
    /// </summary>
    bool splitPayment = false;
    /// <summary>
    /// controls the disabled state of fixedMonthly
    /// </summary>
    bool fixedMonthly = false;
    bool isTopDropDownOpen = true;
    bool isButtomDropDownOpen = false;
    bool openTagsMenu = false;
    bool isValueTypedAfterReset = false;
    bool isReapetedBtnClicked = false;
    bool openSubCatsOptions = false;
    private int selectedNumber = 1; // Default value
    bool disBtn = false;
    bool disNextBtn = false;
    bool isTagChosen = false;
    bool isResetBtnClicked = false;
    string disBtnStyle => disBtn ? "disBtn" : "";
    string disNextBtnStyle => disNextBtn ? "disBtn" : "";
    string chosenTagStyle => isTagChosen ? "chosenTag" : "";
    string textOnResetBtn => isResetBtnClicked ? "חזרה לסכומים המקוריים" : "איפוס סכומים חוזרים";
    string hiddenReOverlay = "";
    string pastMonthStyle = "";
    string thisMonthDivStyle = "";


    double currentGap = 0;
    double budgetSumToMove = 0;
    string overdraftClass = "outerOverdraft";
    bool overdraftOverlay = false;


    public string overlayTitle = "";
    public string repeatedBtnTitle = "הגדרת ההזנה כחוזרת";
    //string clikckedTag => isTagClicked ? "border: solid,0.1em,black" : "border:none";
    bool returningTrans = false;

    int monthNum = 0;
    bool resetMonthValues = false;
    private List<string> months = new List<string>
    {
    "January", "February", "March", "April", "May", "June",
    "July", "August", "September", "October", "November", "December"
    };
    private bool isValueTyped = false;
    private string GetCurrentMonth() => DateTime.Now.ToString("MMMM");
    private Dictionary<string, string> monthsAndValues = new Dictionary<string, string>();

    /// <summary>
    /// fixed monthly children, values are only added to this list when the user inputs a fixed child
    /// </summary>
    List<TransactionToAdd> fixedTransChildrenToAdd = new List<TransactionToAdd>();

    /// <summary>
    /// fixed monthly/ split payment children in DB
    /// </summary>
    List<RepeatedTransToShow> reapeatedTransValuesList = new List<RepeatedTransToShow>();

    int indexOfPayment = 0;

    bool isRepeatedTrans = false;
    bool isSplitedTrans = false;
    bool secondSplit = false;

    string disSpClass => isRepeatedTrans ? "disabled" : "";
    string disReClass => splitPayment ? "disabled" : "";

    bool? initialFixedMonthly = false;
    bool? initialSplitPayment = false;
    int initialAmountOfSplits = 1;
    double sumPreSplit = 0;
    //TransactionToAdd ogTransaction = new TransactionToAdd();

    bool isLoadComplete = false;
    int currentStreak = 0;

    bool isTyped = false;
    bool isTransSumTyped = false;
    bool emptyTagName = false;

    private int currentPage = 0;
    private int pageSize = 5;
    private int totalPages => (int)Math.Ceiling(allUserTags.Count / (double)pageSize);

    private List<TagsToShow> GetTags()
    {
        // Fetch or generate your list of tags
        return new List<TagsToShow>
    {
    new TagsToShow { id = 1, tagTitle = "Tag1", tagColor = "#ff0000" },
    new TagsToShow { id = 2, tagTitle = "Tag2", tagColor = "#00ff00" },
    // Add more tags as needed
    };
    }

    string titleInput = "";
    int titleInputLength = 0;

    string descriptionInput = "";

    bool createTagOverlay = false;
    bool transDisplay = true;
    TagsToShow createdTag = new TagsToShow();
    string currentTagName = "";
    int tagNameLength = 0;
    string nameInputPlaceholder = "";

    private void NextPage()
    {
        if (currentPage < totalPages - 1)
        {
            disBtn = false;
            disNextBtn = false;
            currentPage++;
        }
        if (currentPage == totalPages - 1)
        {
            disNextBtn = true;
        }
    }

    private void PreviousPage()
    {
        if (currentPage > 0)
        {
            disNextBtn = false;
            disBtn = false;
            currentPage--;
        }
        if (currentPage == 0)
        {
            disBtn = true;
        }

    }

    private IEnumerable<TagsToShow> GetCurrentPageTags()
    {
        return allUserTags.Skip(currentPage * pageSize).Take(pageSize);
    }

    public string GetHebrewMonthName(string month)
    {
        return month switch
        {
            "January" => "ינואר",
            "February" => "פברואר",
            "March" => "מרץ",
            "April" => "אפריל",
            "May" => "מאי",
            "June" => "יוני",
            "July" => "יולי",
            "August" => "אוגוסט",
            "September" => "ספטמבר",
            "October" => "אוקטובר",
            "November" => "נובמבר",
            "December" => "דצמבר",
            _ => "חודש לא תקין",
        };
    }

    private bool IsPastMonth(string month)
    {
        pastMonthStyle = "disMonth";
        //int currentMonthIndex = months.IndexOf(GetCurrentMonth());
        int monthIndex = months.IndexOf(month);
        //return monthIndex < currentMonthIndex;

        int releventMonthIndex = months.IndexOf(newTransaction.transDate.ToString("MMMM"));
        Console.WriteLine("monthIndex- " + monthIndex + ", releventMonthIndex- " + releventMonthIndex);
        return monthIndex < releventMonthIndex;
    }


    private string GetDefaultValue(string month)
    {
        if (fixedTransChildrenToAdd.Count > 0)
        {
            DateTime date = DateTime.ParseExact(month, "MMMM", System.Globalization.CultureInfo.InvariantCulture);
            int monthNumber = date.Month;
            var existingChild = fixedTransChildrenToAdd.FirstOrDefault(t => t.transDate.Month == monthNumber);
            if (existingChild != null)
            {
                return IsPastMonth(month) ? "0" : existingChild.transValue.ToString();
            }
            //return IsPastMonth(month) ? "0" : newTransaction.transValue.ToString();
        }

        return IsPastMonth(month) ? "0" : newTransaction.transValue.ToString();

    }

    /// <summary>
    /// checks if the day exists in a specific month
    /// </summary>
    bool DayExistsInMonth(int year, int month, int day)
    {
        try
        {
            DateTime date = new DateTime(year, month, day);
            return true;
        }
        catch (ArgumentOutOfRangeException)
        {
            return false;
        }
    }

    /// <summary>
    /// gets the last day of the month
    /// </summary>

    DateTime GetLastDayOfMonth(int year, int month)
    {
        // Create a DateTime object for the first day of the next month
        DateTime firstDayOfNextMonth = new DateTime(year, month, 1).AddMonths(1);

        // Subtract one day to get the last day of the current month
        DateTime lastDayOfMonth = firstDayOfNextMonth.AddDays(-1);

        return lastDayOfMonth;
    }

    /// <summary>
    /// checks if the date for the trans child exists and if not sets it to the last day of the wanted month
    /// </summary>
    private DateTime checkDateExistsInMonth(DateTime dateOfChild, int wantedMonth)
    {
        DateTime dateToCheck = dateOfChild;
        DateTime newChildDate;
        //checks if the day of the trans child exists in the month the user wants it to be in
        if (DayExistsInMonth(dateToCheck.Year, wantedMonth, dateToCheck.Day))
        {
            newChildDate = new DateTime(dateToCheck.Year, wantedMonth, dateToCheck.Day);

        }
        else
        {
            //if the date doesnt exist it inserts the last day of the month as the trans child's date
            DateTime lastDay = GetLastDayOfMonth(dateToCheck.Year, wantedMonth);
            newChildDate = new DateTime(dateToCheck.Year, wantedMonth, lastDay.Day);
        }
        return newChildDate;
    }


    void backToTrans()
    {
        hiddenReOverlay = "display:none;";
        returningTrans = false;


        if (fixedTransChildrenToAdd.Count > 0)
        {
            //isRepeatedTrans = true;
            int unfitTrans = 0;
            foreach (TransactionToAdd t in fixedTransChildrenToAdd)
            {
                if (t.transDate.Month > DateTime.Today.Month)
                {
                    if (t.transValue <= 0)
                    {
                        unfitTrans++;
                    }

                }
            }

            int monthsToRepeat = 12 - newTransaction.transDate.Month;
            if (unfitTrans < monthsToRepeat) //if there are valid values in future months
            {
                newTransaction.fixedMonthly = true;
                if (categoryTypeIndicator)
                {
                    repeatedBtnTitle = "עריכת ההכנסה החוזרת";
                }
                else
                {
                    repeatedBtnTitle = "עריכת ההוצאה החוזרת";
                }
            }
            else
            {
                newTransaction.fixedMonthly = false;
                //isRepeatedTrans = false;
                //fixedTransChildrenToAdd = new List<TransactionToAdd>();
            }

        }
        else
        {
            //isRepeatedTrans = false;
            newTransaction.fixedMonthly = false;
        }

    }




    /// <summary>
    /// In fixedMonthly overlay-handles values when the parent was not already fixedMonthly
    /// </summary>
    private void HandleInput(ChangeEventArgs e, string monthName)
    {

        isValueTypedAfterReset = true;


        int currentDay = newTransaction.transDate.Day;
        int currentYear = newTransaction.transDate.Year;

        // Build the date string using today's day, the given month, and the current year
        string dateString = $"{currentDay} {monthName} {currentYear}";

        DateTime date;
        if (DateTime.TryParseExact(dateString, "d MMMM yyyy", CultureInfo.InvariantCulture, DateTimeStyles.None, out date))
        {
            Console.WriteLine(date.ToString("yyyy-MM-dd"));
        }
        else
        {
            Console.WriteLine("Invalid month name or format.");
        }

        date = checkDateExistsInMonth(date, date.Month);
        Console.WriteLine("child date- " + date);

        string newValue = e.Value?.ToString();
        if (int.TryParse(newValue, out int _))
        {
            isValueTyped = true;  // Set the flag to true if the input is a number

        }
        if (newValue == null || newValue == "")
        {
            newValue = "0";
        }

        foreach (TransactionToAdd repeatedTrans in fixedTransChildrenToAdd)
        {
            if (repeatedTrans.transDate == date)
            {
                repeatedTrans.transValue = double.Parse(newValue); //updates the list of the children that are to be added (the temp list in page)

                var transInEditList = potentialFixedChildren.FirstOrDefault(t => t.transDate == date);
                if (transInEditList != null)
                {
                    int indexOfCurrentT = potentialFixedChildren.IndexOf(repeatedTrans);
                    potentialFixedChildren[indexOfCurrentT].transValue = repeatedTrans.transValue;
                }
                else
                {
                    potentialFixedChildren.Add(repeatedTrans);
                }

            }

        }

    }

    /// <summary>
    /// In fixedMonthly overlay- handles values when the parent was already fixedMonthly, and if a value doesn't exist, it is added
    /// </summary>
    private void HandleRepeatedInput(ChangeEventArgs eventArgs, string month, RepeatedTransToShow existingTrans)
    {
        // Check if the input value is not null or empty and parse it to double
        if (string.IsNullOrEmpty(eventArgs.Value?.ToString()))
        {
            // If the input is empty, consider it as zero (or handle as needed)
            eventArgs.Value = 0;

        }

        double parsedValue = 0;
        // Attempt to parse the input value, and default to 0 if parsing fails
        if (!double.TryParse(eventArgs.Value.ToString(), out parsedValue))
        {
            parsedValue = 0; // Optional: add error handling or user feedback here
        }

        if (existingTrans != null) //means this trans child exists in DB
        {
            // Update the existing transaction
            existingTrans.transValue = parsedValue;
            if (reapeatedTransValuesList.Contains(existingTrans))
            {
                //finds the child trans in the list of the children that are already in DB
                int indexOfChild = reapeatedTransValuesList.IndexOf(existingTrans);
                reapeatedTransValuesList[indexOfChild] = existingTrans;

                //finds the child trans in the list of the children that are only in the page and are to be added/edited
                var findMatchTrans = fixedTransChildrenToAdd.FirstOrDefault(t => t.transDate == existingTrans.transDate);
                int indexOfMatch = fixedTransChildrenToAdd.IndexOf(findMatchTrans);

                fixedTransChildrenToAdd[indexOfMatch].transDate = checkDateExistsInMonth(fixedTransChildrenToAdd[indexOfMatch].transDate, fixedTransChildrenToAdd[indexOfMatch].transDate.Month); //checks if the date is valid, and if not sets it to be the last day of that month

                fixedTransChildrenToAdd[indexOfMatch].transValue = existingTrans.transValue;

                var transInEditList = potentialFixedChildren.FirstOrDefault(t => t.transDate == existingTrans.transDate);
                if (transInEditList != null)
                {
                    int indexOfCurrentT = potentialFixedChildren.IndexOf(transInEditList);
                    potentialFixedChildren[indexOfCurrentT].transValue = existingTrans.transValue;
                }

            }
        }
        else
        {
            // Optionally add a new transaction if it does not exist, this block now only executes if there's no existing transaction
            int parsedMonth = int.Parse(month);
            var newTrans = new TransactionToAdd
                {
                    //checks if the date is valid, and if not sets it to be the last day of that month:
                    transDate = checkDateExistsInMonth(newTransaction.transDate, parsedMonth),
                    transValue = 0
                };
            Console.WriteLine("input was null");
            fixedTransChildrenToAdd.Add(newTrans);
            potentialFixedChildren.Add(newTrans);

        }
    }


    protected override async Task OnInitializedAsync()
    {
        if (userID > 0)
        {
            var getStartMonthDate = await Http.GetAsync("api/Present/getUserMonthStartDate/" + userID);
            if (getStartMonthDate.IsSuccessStatusCode)
            {
                userStartMonthDay = await getStartMonthDate.Content.ReadFromJsonAsync<int>();
            }
            else
            {
                Console.WriteLine("failed to get users start month date, setting it to 1");
                userStartMonthDay = 1;
            }
        }

        if (transIDtoEdit > 0) //means it's an existing transaction
        {
            if (categoryTypeIndicator)
            {
                overlayTitle = "עריכת הכנסה";

            }
            else
            {
                overlayTitle = "עריכת הוצאה";
            }

            isItAnewTrans = false;

            var transEditRes = await Http.GetAsync("api/Transactions/getSplitParent/" + transIDtoEdit); //doesn't necessarily mean that the transaction is a split parent/child, this gets the entire data of a specific transaction by its ID
            if (transEditRes.IsSuccessStatusCode)
            {
                ogTransaction = await transEditRes.Content.ReadFromJsonAsync<TransactionToEdit>();
                if (ogTransaction != null)
                {
                    //links the original trans (that's in DB) to the form's trans
                    newTransaction = new TransactionToAdd()
                        {
                            subCategoryID = subCategoryIDTOGet,
                            transValue = ogTransaction.transValue,
                            transType = ogTransaction.transType,
                            valueType = ogTransaction.valueType,
                            transDate = ogTransaction.transDate,
                            fixedMonthly = ogTransaction.fixedMonthly,
                            tagID = ogTransaction.tagID,
                            tagTitle = ogTransaction.tagTitle,
                            tagColor = ogTransaction.tagColor,
                            transTitle = ogTransaction.transTitle,
                            parentTransID = ogTransaction.parentTransID,
                            description = ogTransaction.description,
                            splitPayment = ogTransaction.splitPayment
                        };

                    if (newTransaction.tagID > 0)
                    {
                        chosenTag.id = newTransaction.tagID.Value;
                        chosenTag.tagTitle = newTransaction.tagTitle;
                        chosenTag.tagColor = newTransaction.tagColor;
                    }
                    if (newTransaction.description != null && newTransaction.description.Length > 0)
                    {
                        descriptionInput = newTransaction.description;
                        descLength = newTransaction.description.Length;
                    }

                    Console.WriteLine(newTransaction.tagTitle + "התגית שלי היא");

                    Console.WriteLine(newTransaction.transTitle);
                    titleInput = newTransaction.transTitle;
                    initialSplitPayment = newTransaction.splitPayment;
                    initialFixedMonthly = newTransaction.fixedMonthly;

                    if (newTransaction.fixedMonthly == true)
                    {
                        if (categoryTypeIndicator)
                        {
                            repeatedBtnTitle = "עריכת ההכנסה החוזרת";
                        }
                        else
                        {
                            repeatedBtnTitle = "עריכת ההוצאה החוזרת";
                        }

                        fixedMonthly = false; //disables the split payment option
                        splitPayment = !fixedMonthly;
                        var getRepeatedChildren = await Http.GetAsync("api/Transactions/getRepeatedTransToEdit/" + transIDtoEdit); //gets the fixed children only
                        if (getRepeatedChildren.IsSuccessStatusCode)
                        {
                            reapeatedTransValuesList = getRepeatedChildren.Content.ReadFromJsonAsync<List<RepeatedTransToShow>>().Result;
                        }
                        else
                        {
                            Console.WriteLine("failed to get related repeated transactions");
                        }
                    }
                    else if (newTransaction.splitPayment == true)
                    {
                        splitPayment = true;
                        //fixedMonthly = !splitPayment;

                        var repeatedTransValuesRes = await Http.GetAsync("api/Transactions/getPaymentTransToEdit/" + transIDtoEdit);


                        if (repeatedTransValuesRes.IsSuccessStatusCode)
                        {
                           
                            reapeatedTransValuesList = repeatedTransValuesRes.Content.ReadFromJsonAsync<List<RepeatedTransToShow>>().Result;
                            foreach (RepeatedTransToShow repeatedT in reapeatedTransValuesList)
                            {
                                if (repeatedT.id == transIDtoEdit)
                                {
                                    indexOfPayment = reapeatedTransValuesList.IndexOf(repeatedT) + 1;
                                }
                            }
                            selectedNumber = reapeatedTransValuesList.Count;
                            initialAmountOfSplits = selectedNumber;
                            sumPreSplit = newTransaction.transValue * initialAmountOfSplits;
                            newTransaction.transValue = sumPreSplit;
                            Console.WriteLine("sum pre split- " + sumPreSplit);
                            Console.WriteLine("newTransaction.transValue- " + newTransaction.transValue);
                            List<int> transStatus = new List<int>()
    {
    indexOfPayment, selectedNumber
    };
                            SplitPaymentWithIndex.InvokeAsync(transStatus);

                        }
                        else
                        {
                            Console.WriteLine("repeated Trans values failed");
                            splitPayment = false;
                        }
                    }

                    if (newTransaction.fixedMonthly == false)
                    {
                        fixedMonthly = false;
                        
                        if (categoryTypeIndicator)
                        {
                            repeatedBtnTitle = "הגדרת ההכנסה החוזרת";
                        }
                        else
                        {
                            repeatedBtnTitle = "הגדרת ההוצאה החוזרת";
                        }
                    }

                    if (newTransaction.splitPayment == false)
                    {
                        initialAmountOfSplits = 1;
                        selectedNumber = 1;
                        splitPayment = false;
                        
                    }

                }
                else
                {
                    Console.WriteLine("transaction with this ID- " + transIDtoEdit + " returned null");
                }
            }
            else
            {
                Console.WriteLine("failed to find/get transaction with this ID- " + transIDtoEdit);
            }
        }
        else //means it's a new transaction
        {
            newTransaction = new TransactionToAdd()
                {
                    transDate = DateTime.Today, // Set the transaction date to today
                    fixedMonthly = false,
                    splitPayment = false,

                };

            fixedMonthly = false;
            splitPayment = false;
            overlayTitle = "הוספה לתת קטגוריה";
            isItAnewTrans = true;
            //isLoadComplete = true;
            Console.WriteLine("transaction value type is- " + categoryTypeIndicator);

            if (categoryTypeIndicator)
            {
                repeatedBtnTitle = "הגדרת ההכנסה החוזרת";
                nameInputPlaceholder = "שם ההכנסה שלי";
            }
            else
            {
                repeatedBtnTitle = "הגדרת ההוצאה החוזרת";
                nameInputPlaceholder = "שם ההוצאה שלי";
            }

        }

        isLoadComplete = true;
    }


    private void HandleChange(OverBudgetToShow chosenSubCat)
    {

        chosenSubCategory = chosenSubCat;
        openSubCatsOptions = !openSubCatsOptions;
    }

    public async Task saveAndEndTransactions()
    {

        newTransaction.transValue = Math.Round(newTransaction.transValue);
        newTransaction.subCategoryID = subCategoryIDTOGet;
        newTransaction.tagID = null;
        if (!categoryTypeIndicator)
        {
            newTransaction.transType = 1; //expense
        }
        else
        {
            newTransaction.transType = 2; //income
        }
        if (chosenTag.id > 0)
        {
            newTransaction.tagID = chosenTag.id;
        }


        if (newTransaction.fixedMonthly == true) //means the trans is fixedMonthly
        {

            var transToSaveRes = await Http.PostAsJsonAsync("api/Transactions/AddTransaction", newTransaction);
            if (transToSaveRes.IsSuccessStatusCode)
            {
                transIDtoEdit = await transToSaveRes.Content.ReadFromJsonAsync<int>();
                if (!categoryTypeIndicator)
                {
                    if (newTransaction.transDate.Month == DateTime.Today.Month && newTransaction.transDate.Day >= userStartMonthDay)
                    {
                        await checkOverdraft();
                        if (overdraftDetected)
                        {
                            var transOverdraftRes = await Http.GetAsync("api/Transactions/updateOverDraftTrans/" + transIDtoEdit); //updates the transType to 3
                            if (transOverdraftRes.IsSuccessStatusCode)
                            {

                                Console.WriteLine("ההזנה עודכנה לחורגת בהצלחה :)");
                            }
                        }
                        else
                        {

                        }
                    }
                    isTyped = false;
                }


                await saveRepeatedTransactions(transIDtoEdit); //saves the children separately

                isTyped = false;
                Console.WriteLine("ההזנה נשמרה בהצלחה :)");
                if (newTransaction.transDate.Month == DateTime.Today.Month && newTransaction.transDate.Day >= userStartMonthDay && newTransaction.transDate.Day <= DateTime.Today.Day) //checks if the users month has started and then adds it to the total
                {
                    addTransactionToTotal.InvokeAsync(newTransaction.transValue);

                }

            }
            else
            {
                Console.WriteLine("הזנה נכשלה");
            }

        }
        else if (newTransaction.splitPayment == true && selectedNumber > 1) //means the trans is split
        {
            double splitValue = newTransaction.transValue / selectedNumber;
            for (int i = 0; i < selectedNumber; i++)
            {
                newTransaction.transValue = splitValue;
                if (i > 0)
                {
                    newTransaction.transDate = newTransaction.transDate.AddMonths(1);
                    newTransaction.parentTransID = transIDtoEdit;
                    newTransaction.splitPayment = false;
                }

                var transToSaveRes = await Http.PostAsJsonAsync("api/Transactions/AddTransaction", newTransaction);
                if (transToSaveRes.IsSuccessStatusCode)
                {
                    if (i == 0)
                    {

                        transIDtoEdit = await transToSaveRes.Content.ReadFromJsonAsync<int>();
                    }
                    if (!categoryTypeIndicator)
                    {
                        if (i == 0)
                        {
                            if (newTransaction.transDate.Month == DateTime.Today.Month && newTransaction.transDate.Day >= userStartMonthDay)
                            {
                                await checkOverdraft();
                                if (overdraftDetected)
                                {
                                    var transOverdraftRes = await Http.GetAsync("api/Transactions/updateOverDraftTrans/" + transIDtoEdit); //updates the transType to 3
                                    if (transOverdraftRes.IsSuccessStatusCode)
                                    {

                                        Console.WriteLine("ההזנה עודכנה לחורגת בהצלחה :)");

                                    }
                                }
                            }
                        }
                        Console.WriteLine("ההזנה נשמרה בהצלחה :)");

                        isTyped = false;
                        if (newTransaction.transDate.Month == DateTime.Today.Month && newTransaction.transDate.Day >= userStartMonthDay)
                        {
                            addTransactionToTotal.InvokeAsync(newTransaction.transValue);

                        }

                    }
                    else
                    {
                        Console.WriteLine("ההזנה נשמרה בהצלחה :)");

                        isTyped = false;
                        if (newTransaction.transDate.Month == DateTime.Today.Month && newTransaction.transDate.Day >= userStartMonthDay)
                        {
                            addTransactionToTotal.InvokeAsync(newTransaction.transValue);

                        }
                    }
                }
                else
                {
                    Console.WriteLine("הזנה נכשלה");
                }
            }



        }
        else //means the trans is not split or fixed
        {
            var transToSaveRes = await Http.PostAsJsonAsync("api/Transactions/AddTransaction", newTransaction);
            if (transToSaveRes.IsSuccessStatusCode)
            {
                transIDtoEdit = await transToSaveRes.Content.ReadFromJsonAsync<int>();
                if (!categoryTypeIndicator)
                {
                    if (newTransaction.transDate.Month == DateTime.Today.Month && newTransaction.transDate.Day >= userStartMonthDay)
                    {
                        await checkOverdraft();
                        if (overdraftDetected)
                        {
                            var transOverdraftRes = await Http.GetAsync("api/Transactions/updateOverDraftTrans/" + transIDtoEdit); //updates the transType to 3
                            if (transOverdraftRes.IsSuccessStatusCode)
                            {

                                Console.WriteLine("ההזנה עודכנה לחורגת בהצלחה :)");
                            }
                        }
                    }
                    isTyped = false;
                    Console.WriteLine("ההזנה נשמרה בהצלחה :)");
                }
                if (newTransaction.transDate.Month == DateTime.Today.Month && newTransaction.transDate.Day >= userStartMonthDay)
                {
                    addTransactionToTotal.InvokeAsync(newTransaction.transValue);


                }


            }
            else
            {
                Console.WriteLine("הזנה נכשלה");
            }
        }
        if (!overdraftDetected && closeOverdraftOpts.Count < 1 || !overdraftDetected && closeOverdraftOpts.Count != 1 && closeOverdraftOpts[closeOverdraftOpts.Count - 1].id != subCategoryIDTOGet)
        {
            isTransactionOverlayOpen.InvokeAsync(false);

        }

    }

    public async Task saveAndRepeatTransactions()
    {
        Console.WriteLine("DateTime.Today.Month- " + DateTime.Today.Month);
        newTransaction.transValue = Math.Round(newTransaction.transValue);
        newTransaction.subCategoryID = subCategoryIDTOGet;
        if (newTransaction.tagID <= 0)
        {
            newTransaction.tagID = null;
        }
        newTransaction.tagID = null;
        if (!categoryTypeIndicator)
        {
            newTransaction.transType = 1;
        }
        else
        {
            newTransaction.transType = 2;
        }

        if (chosenTag.id > 0)
        {
            newTransaction.tagID = chosenTag.id;
        }
        if (newTransaction.fixedMonthly == true) //means the trans is fixedMonthly
        {

            var transToSaveRes = await Http.PostAsJsonAsync("api/Transactions/AddTransaction", newTransaction);
            if (transToSaveRes.IsSuccessStatusCode)
            {
                transIDtoEdit = await transToSaveRes.Content.ReadFromJsonAsync<int>();
                if (!categoryTypeIndicator)
                {
                    if (newTransaction.transDate.Month == DateTime.Today.Month && newTransaction.transDate.Day >= userStartMonthDay)
                    {
                        await checkOverdraft();
                        if (overdraftDetected)
                        {
                            var transOverdraftRes = await Http.GetAsync("api/Transactions/updateOverDraftTrans/" + transIDtoEdit); //updates the transType to 3
                            if (transOverdraftRes.IsSuccessStatusCode)
                            {
                                overdraftOverlay = true;
                                Console.WriteLine("ההזנה עודכנה לחורגת בהצלחה :)");
                            }
                        }
                    }
                    isTyped = false;
                }


                await saveRepeatedTransactions(transIDtoEdit); //saves the children separately

                isTyped = false;
                Console.WriteLine("ההזנה נשמרה בהצלחה :)");
                if (newTransaction.transDate.Month == DateTime.Today.Month && newTransaction.transDate.Day >= userStartMonthDay)
                {
                    addTransactionToTotal.InvokeAsync(newTransaction.transValue);


                }



            }
            else
            {
                Console.WriteLine("הזנה נכשלה");
            }

        }
        else if (newTransaction.splitPayment == true && selectedNumber > 1) //means the trans is split
        {
            double splitValue = newTransaction.transValue / selectedNumber;
            int initialTransID = transIDtoEdit; // Store the initial transaction ID

            for (int i = 0; i < selectedNumber; i++)
            {
                newTransaction.transValue = splitValue;
                if (i > 0)
                {
                    newTransaction.transDate = newTransaction.transDate.AddMonths(1);
                    newTransaction.parentTransID = transIDtoEdit;
                    newTransaction.splitPayment = false;
                }

                var transToSaveRes = await Http.PostAsJsonAsync("api/Transactions/AddTransaction", newTransaction);
                if (transToSaveRes.IsSuccessStatusCode)
                {
                    if (i == 0)
                    {

                        transIDtoEdit = await transToSaveRes.Content.ReadFromJsonAsync<int>();
                    }
                    if (!categoryTypeIndicator && i == 0)
                    {
                        if (newTransaction.transDate.Month == DateTime.Today.Month && newTransaction.transDate.Day >= userStartMonthDay)
                        {
                            await checkOverdraft();
                            if (overdraftDetected)
                            {
                                var transOverdraftRes = await Http.GetAsync("api/Transactions/updateOverDraftTrans/" + transIDtoEdit); //updates the transType to 3
                                if (transOverdraftRes.IsSuccessStatusCode)
                                {
                                    overdraftOverlay = true;
                                    Console.WriteLine("ההזנה עודכנה לחורגת בהצלחה :)");
                                }
                            }
                        }
                        isTyped = false;
                        Console.WriteLine("ההזנה נשמרה בהצלחה :)");

                        if (newTransaction.transDate.Month == DateTime.Today.Month && newTransaction.transDate.Day >= userStartMonthDay)
                        {
                            addTransactionToTotal.InvokeAsync(newTransaction.transValue);

                        }

                    }
                }
                else
                {
                    Console.WriteLine("הזנה נכשלה");
                }
            }


        }
        else //means the trans is not split or fixed
        {
            var transToSaveRes = await Http.PostAsJsonAsync("api/Transactions/AddTransaction", newTransaction);
            if (transToSaveRes.IsSuccessStatusCode)
            {
                transIDtoEdit = await transToSaveRes.Content.ReadFromJsonAsync<int>();
                if (!categoryTypeIndicator)
                {
                    if (newTransaction.transDate.Month == DateTime.Today.Month && newTransaction.transDate.Day >= userStartMonthDay)
                    {

                        await checkOverdraft();
                        if (overdraftDetected)
                        {
                            var transOverdraftRes = await Http.GetAsync("api/Transactions/updateOverDraftTrans/" + transIDtoEdit); //updates the transType to 3
                            if (transOverdraftRes.IsSuccessStatusCode)
                            {
                                overdraftOverlay = true;
                                Console.WriteLine("ההזנה עודכנה לחורגת בהצלחה :)");
                            }
                        }
                    }
                    addTransactionToTotal.InvokeAsync(newTransaction.transValue);


                    Console.WriteLine("ההזנה נשמרה בהצלחה :)");
                }
                else
                {
                    if (newTransaction.transDate.Month == DateTime.Today.Month && newTransaction.transDate.Day >= userStartMonthDay)
                    {
                        addTransactionToTotal.InvokeAsync(newTransaction.transValue);

                    }


                }

            }
            else
            {
                Console.WriteLine("הזנה נכשלה");
            }
        }
        if (!overdraftDetected && closeOverdraftOpts.Count < 1 || !overdraftDetected && closeOverdraftOpts.Count != 1 && closeOverdraftOpts[closeOverdraftOpts.Count - 1].id != subCategoryIDTOGet)
        {
            titleInput = "";
            isTyped = false;
            titleInputLength = 0;
            newTransaction = new TransactionToAdd()
                {
                    transDate = DateTime.Today, // Set the transaction date to today
                    fixedMonthly = false,
                    splitPayment = false,
                    transValue = 0,
                    description = null
                };
            isButtomDropDownOpen = false;
            isTopDropDownOpen = true;
            chosenTag = new TagsToShow();
            descLength = 0;
            descriptionInput = "";
            fixedTransChildrenToAdd = new List<TransactionToAdd>();
            reapeatedTransValuesList = new List<RepeatedTransToShow>();
        }
    }


    public async Task updateExistingTrans()
    {

        newTransaction.transValue = Math.Round(newTransaction.transValue);
        if (!categoryTypeIndicator)
        {
            newTransaction.transType = 1;
        }
        else
        {
            newTransaction.transType = 2;
        }

        if (newTransaction.description == "")
        {
            newTransaction.description = null;
        }
        TransactionToEdit transToEdit = new TransactionToEdit()
            {
                id = transIDtoEdit,
                transValue = newTransaction.transValue,
                transType = newTransaction.transType,
                valueType = newTransaction.valueType,
                transDate = newTransaction.transDate,
                fixedMonthly = newTransaction.fixedMonthly,
                tagID = chosenTag.id,
                tagColor = chosenTag.tagColor,
                tagTitle = chosenTag.tagTitle,
                transTitle = newTransaction.transTitle,
                parentTransID = newTransaction.parentTransID,
                description = newTransaction.description,
                splitPayment = newTransaction.splitPayment
            };
        if (transToEdit.tagID == 0)
        {
            transToEdit.tagID = null;
            transToEdit.tagColor = null;
            transToEdit.tagTitle = null;
        }
        if (!transToEdit.splitPayment)
        {
            selectedNumber = 1;
        }
        else
        {
            if(selectedNumber > 1)
            {
                transToEdit.transValue = sumPreSplit / selectedNumber;
            }
        }

        if (initialAmountOfSplits > 1)
        {

            transToEdit.transValue = sumPreSplit / selectedNumber;
        }


        if (categoryTypeIndicator)
        {
            transToEdit.transType = 2;
        }
        else
        {
            transToEdit.transType = 1;
        }


        var transEditRes = await Http.PostAsJsonAsync("api/Transactions/editTransaction", transToEdit);
        if (transEditRes.IsSuccessStatusCode)
        {
            Console.WriteLine("ההזנה עודכנה בהצלחה :)");
            if (!categoryTypeIndicator)
            {
                if (newTransaction.transDate.Month == DateTime.Today.Month && newTransaction.transDate.Day >= userStartMonthDay)
                {

                    await checkOverdraft();
                    if (overdraftDetected)
                    {
                        var transOverdraftRes = await Http.GetAsync("api/Transactions/updateOverDraftTrans/" + transIDtoEdit); //updates the transType to 3
                        if (transOverdraftRes.IsSuccessStatusCode)
                        {
                            //overdraftOverlay = true;
                            Console.WriteLine("ההזנה עודכנה לחורגת בהצלחה :)");
                        }
                    }
                }

            }

            TransactionToEdit postEditTrans = await transEditRes.Content.ReadFromJsonAsync<TransactionToEdit>();
            if (postEditTrans != null)
            {

                if (postEditTrans.splitPayment && postEditTrans.splitPayment == initialSplitPayment || postEditTrans.splitPayment && initialAmountOfSplits == selectedNumber) //means this transaction is a part of a split payment
                {
                    if (postEditTrans.transTitle != ogTransaction.transTitle || postEditTrans.transValue != ogTransaction.transValue || postEditTrans.transDate != ogTransaction.transDate || postEditTrans.valueType != ogTransaction.valueType || postEditTrans.description != ogTransaction.description || postEditTrans.tagID != ogTransaction.tagID || postEditTrans.transDate != ogTransaction.transDate) //if any change was done to the parent regardless of split payments amount
                    {
                        Console.WriteLine("new split amount is- " + transToEdit.transValue);

                        var deleteSplitChildren = await Http.DeleteAsync("api/Transactions/deleteSplittedChildrenOnly/" + postEditTrans.id);
                        if (deleteSplitChildren.IsSuccessStatusCode)
                        {
                            //deleting all children so we create new ones according to the new amount
                            Console.WriteLine("all former split children of this transaction were deleted");
                            for (int j = 1; j < selectedNumber; j++)
                            {

                                DateTime newChildDate = postEditTrans.transDate.AddMonths(j);
                                transToEdit.parentTransID = postEditTrans.id;
                                transToEdit.splitPayment = false;

                                TransactionToAdd updatedChildTransOfEdit = new TransactionToAdd()
                                    {
                                        transValue = transToEdit.transValue,
                                        valueType = transToEdit.valueType,
                                        description = transToEdit.description,
                                        fixedMonthly = transToEdit.fixedMonthly,
                                        parentTransID = transToEdit.id,
                                        tagID = transToEdit.tagID,
                                        tagTitle = transToEdit.tagTitle,
                                        tagColor = transToEdit.tagColor,
                                        transTitle = transToEdit.transTitle,
                                        subCategoryID = subCategoryIDTOGet,
                                        transDate = newChildDate,
                                        transType = transToEdit.transType,
                                        splitPayment = transToEdit.splitPayment
                                    };

                                var transToSaveRes = await Http.PostAsJsonAsync("api/Transactions/AddTransaction", updatedChildTransOfEdit);
                                if (transToSaveRes.IsSuccessStatusCode)
                                {
                                    Console.WriteLine("child of date- " + updatedChildTransOfEdit.transDate + " was saved successfully");

                                }
                                else
                                {
                                    Console.WriteLine("couldn't add the split payment");

                                }

                            }

                        }
                        else
                        {
                            Console.WriteLine("failed to delete former split children and create the new ones.");
                        }
                    }
                }


                editedTransaction.id = postEditTrans.id;
                editedTransaction.transValue = postEditTrans.transValue;
                editedTransaction.transType = postEditTrans.transType;
                editedTransaction.valueType = postEditTrans.valueType;

                editedTransaction.fixedMonthly = postEditTrans.fixedMonthly;
                editedTransaction.tagID = postEditTrans.tagID;
                editedTransaction.tagColor = postEditTrans.tagColor;
                editedTransaction.tagTitle = postEditTrans.tagTitle;
                editedTransaction.transTitle = postEditTrans.transTitle;
                editedTransaction.parentTransID = postEditTrans.parentTransID;
                editedTransaction.description = postEditTrans.description;
                editedTransaction.splitPayment = postEditTrans.splitPayment;

                if (postEditTrans.splitPayment)
                {

                    DateTime now = DateTime.Now;

                    if (postEditTrans.transDate != now)
                    {
                        int currentMonth = now.Month;
                        int monthsPassed = currentMonth - postEditTrans.transDate.Month;
                        //if(monthsPassed==0){

                        //}
                        DateTime dateOfCurrentSplit = new DateTime(postEditTrans.transDate.Year, currentMonth, postEditTrans.transDate.Day);

                        editedTransaction.transDate = dateOfCurrentSplit.ToShortDateString();

                    }


                }
                else
                {
                    editedTransaction.transDate = postEditTrans.transDate.ToShortDateString();
                }



                if (postEditTrans.splitPayment != initialSplitPayment || initialAmountOfSplits != selectedNumber)
                {
                    await updateSplitPayments(postEditTrans);
                }



                if (postEditTrans.fixedMonthly == true && postEditTrans.fixedMonthly == ogTransaction.fixedMonthly) //means contents were changed
                {

                    foreach (TransactionToAdd repT in fixedTransChildrenToAdd)
                    {
                        var findMatchTrans = reapeatedTransValuesList.FirstOrDefault(t => t.transDate == repT.transDate);
                        if (findMatchTrans != null)
                        {
                            int indexOfMatch = reapeatedTransValuesList.IndexOf(findMatchTrans);
                            reapeatedTransValuesList[indexOfMatch].transValue = repT.transValue;
                        }
                        else if (findMatchTrans == null && repT.transValue > 0 && repT.transDate.Month > DateTime.Today.Month)
                        {
                            RepeatedTransToShow repTtoUpdate = new RepeatedTransToShow()
                                {
                                    id = 0,
                                    transValue = repT.transValue,
                                    transDate = repT.transDate
                                };
                            reapeatedTransValuesList.Add(repTtoUpdate);
                        }

                    }

                    await updateReTransactions(reapeatedTransValuesList);

                }
                else if ((postEditTrans.fixedMonthly != ogTransaction.fixedMonthly) && postEditTrans.fixedMonthly == true) //means children were completely added
                {
                    await saveRepeatedTransactions(postEditTrans.id);
                }
                else if ((postEditTrans.fixedMonthly != ogTransaction.fixedMonthly) && postEditTrans.fixedMonthly == false) //means all children need to be deleted
                {
                    var deleteSplitChildren = await Http.DeleteAsync("api/Transactions/deleteSplittedChildrenOnly/" + postEditTrans.id);
                    if (deleteSplitChildren.IsSuccessStatusCode)
                    {
                        Console.WriteLine("כל החזרות של הזנה זו נמחקו בהצלחה");
                    }
                    else
                    {
                        Console.WriteLine("נכשלה המחיקה של כל החזרות של הזנה זו");
                    }
                }

                if (!overdraftDetected)
                {
                    isTransactionOverlayOpen.InvokeAsync(false); //closes the edit overlay
                }

                if (postEditTrans.transDate.Month == DateTime.Today.Month && postEditTrans.transDate.Day >= userStartMonthDay)
                {

                    addTransactionAfterEdit.InvokeAsync(editedTransaction);
                }
            }
        }
        else
        {
            Console.WriteLine("couldn't save edit");
        }

    }

    /// <summary>
    /// updates a transaction that is a part of a split payment
    /// </summary>
    public async Task updateSplitPayments(TransactionToEdit transToEdit)
    {
        int childAmount = 0;
        int? neededID = 0;
        if (transToEdit.parentTransID != null)
        {
            neededID = transToEdit.parentTransID;

        }
        else
        {
            neededID = transToEdit.id; //means the current trans is the parent
        }
        if (transToEdit.splitPayment == true && selectedNumber > 1 && initialAmountOfSplits == 1) //means the trans was false before and had no children
        {
            //double splitValue = transToEdit.transValue / selectedNumber;
            for (int i = 1; i < selectedNumber; i++)
            {
                //transToEdit.transValue = splitValue;
                transToEdit.transDate = newTransaction.transDate.AddMonths(i);
                transToEdit.transDate = checkDateExistsInMonth(transToEdit.transDate, transToEdit.transDate.Month);
                transToEdit.parentTransID = transIDtoEdit;
                transToEdit.splitPayment = false;

                TransactionToAdd childTransOfEdit = new TransactionToAdd()
                    {
                        transValue = transToEdit.transValue,
                        valueType = transToEdit.valueType,
                        description = transToEdit.description,
                        fixedMonthly = transToEdit.fixedMonthly,
                        parentTransID = transToEdit.id,
                        tagID = transToEdit.tagID,
                        tagTitle = transToEdit.tagTitle,
                        tagColor = transToEdit.tagColor,
                        transTitle = transToEdit.transTitle,
                        subCategoryID = subCategoryIDTOGet,
                        transDate = transToEdit.transDate,
                        transType = transToEdit.transType,
                        splitPayment = transToEdit.splitPayment
                    };

                var transToSaveRes = await Http.PostAsJsonAsync("api/Transactions/AddTransaction", childTransOfEdit);
                if (transToSaveRes.IsSuccessStatusCode)
                {
                    Console.WriteLine("child of date- " + childTransOfEdit.transDate + " was saved successfully");
                    childAmount++;
                }
                else
                {
                    Console.WriteLine("couldn't add the split payment");
                    childAmount--;
                }
            }

            indexOfPayment = 1;
            //add a change of the new total split payments
        }
        else if (transToEdit.splitPayment == true && selectedNumber > 1 && selectedNumber != initialAmountOfSplits) //means a change in the children amount was requested
        {
            Console.WriteLine("new split amount is- " + transToEdit.transValue);

            var deleteSplitChildren = await Http.DeleteAsync("api/Transactions/deleteSplittedChildrenOnly/" + neededID);
            if (deleteSplitChildren.IsSuccessStatusCode)
            {
                //deleting all children so we create new ones according to the new amount
                Console.WriteLine("all former split children of this transaction were deleted");
                for (int j = 1; j < selectedNumber; j++)
                {

                    transToEdit.transDate = newTransaction.transDate.AddMonths(j);
                    transToEdit.transDate = checkDateExistsInMonth(transToEdit.transDate, transToEdit.transDate.Month);
                    transToEdit.parentTransID = transIDtoEdit;
                    transToEdit.splitPayment = false;

                    TransactionToAdd updatedChildTransOfEdit = new TransactionToAdd()
                        {
                            transValue = transToEdit.transValue,
                            valueType = transToEdit.valueType,
                            description = transToEdit.description,
                            fixedMonthly = transToEdit.fixedMonthly,
                            parentTransID = transToEdit.id,
                            tagID = transToEdit.tagID,
                            tagTitle = transToEdit.tagTitle,
                            tagColor = transToEdit.tagColor,
                            transTitle = transToEdit.transTitle,
                            subCategoryID = subCategoryIDTOGet,
                            transDate = transToEdit.transDate,
                            transType = transToEdit.transType,
                            splitPayment = transToEdit.splitPayment
                        };

                    var transToSaveRes = await Http.PostAsJsonAsync("api/Transactions/AddTransaction", updatedChildTransOfEdit);
                    if (transToSaveRes.IsSuccessStatusCode)
                    {
                        Console.WriteLine("child of date- " + updatedChildTransOfEdit.transDate + " was saved successfully");
                        childAmount++;
                    }
                    else
                    {
                        Console.WriteLine("couldn't add the split payment");
                        childAmount--;
                    }

                }
                //indexOfPayment = 1;
            }
            else
            {
                Console.WriteLine("failed to delete former split children and create the new ones.");
            }
        }
        else //means that splitMonthly was turned to false
        {
            var deleteSplitChildren = await Http.DeleteAsync("api/Transactions/deleteSplittedChildrenOnly/" + neededID);
            if (deleteSplitChildren.IsSuccessStatusCode)
            {
                Console.WriteLine("all split children of this transaction were deleted");
            }
            else
            {
                Console.WriteLine("failed to delete split children");
            }
        }
        childAmount += 1;
        if (childAmount == selectedNumber)
        {

            //indexOfPayment = 1;
            List<int> transStatus = new List<int>()
    {
    indexOfPayment, selectedNumber
    };
              
            SplitPaymentWithIndex.InvokeAsync(transStatus);

        }

    }



    public async Task manageBudgetsToTranfer()
    {
        if (budgetSumToMove > 0)
        {
            currentGap = budgetSumToMove;
        }

        budgetToUpdate = new List<OverDraftBudgetToEdit>();

        budgetToUpdate.Add(new OverDraftBudgetToEdit
            {
                id = chosenSubCategory.id,  // ID of chosen subcategory
                monthlyPlannedBudget = chosenSubCategory.monthlyPlannedBudget - currentGap // Updated budget

            });


        budgetToUpdate.Add(new OverDraftBudgetToEdit
            {
                id = overDraftSubCategory.id, // ID of the overdraft subcategory
                monthlyPlannedBudget = overDraftSubCategory.monthlyPlannedBudget + currentGap // Updated budget
            });

        await updateSubCategoryBudget(budgetToUpdate);
        await updateExistingTrans();

        if (!overdraftDetected)
        {
            closeAddTransAfterOverdraft.InvokeAsync();
        }



    }

    public async Task checkOverdraft()
    {
        var overdraftRes = await Http.GetAsync("api/Transactions/showOverdraft/" + newTransaction.subCategoryID + "/" + userID);
        if (overdraftRes.IsSuccessStatusCode)
        {
            overdraftDetected = true;
            closeOverdraftOpts = new List<OverBudgetToShow>();
            closeOverdraftOpts = await overdraftRes.Content.ReadFromJsonAsync<List<OverBudgetToShow>>();

            //closeOverdraftOpts[closeOverdraftOpts.Count - 1] is the current subcategory

            currentGap = Math.Round((closeOverdraftOpts[closeOverdraftOpts.Count - 1].remainingBudget) - (closeOverdraftOpts[closeOverdraftOpts.Count - 1].monthlyPlannedBudget),0);
            budgetSumToMove = currentGap;

            overDraftSubCategory.id = closeOverdraftOpts[closeOverdraftOpts.Count - 1].id;
            overDraftSubCategory.monthlyPlannedBudget = closeOverdraftOpts[closeOverdraftOpts.Count - 1].monthlyPlannedBudget;

        }
        else
        {
            Console.WriteLine("No overdraft detected");
            overdraftDetected = false;

        }
    }

    public async Task updateSubCategoryBudget(List<OverDraftBudgetToEdit> budgetsToUpdate)
    {

        var budgetToSaveRes = await Http.PostAsJsonAsync("api/Transactions/EditSubCategoriesNewBudgets", budgetsToUpdate);
        if (budgetToSaveRes.IsSuccessStatusCode)
        {
            Console.WriteLine("התקציבים עודכנו בהצלחה :)");
            if (newTransaction.transDate.Month == DateTime.Today.Month && newTransaction.transDate.Day >= userStartMonthDay)
            {
                await checkOverdraft();
                if (!overdraftDetected)
                {
                    currentGap = 0;
                    budgetSumToMove = 0;
                    overdraftOverlay = false;
                    isTransactionOverlayOpen.InvokeAsync(false);
                    gapsToUpdateBudgets.InvokeAsync(budgetsToUpdate);
                }
            }

        }
        else
        {
            Console.WriteLine("עדכון התקציבים נכשל");
        }
    }

    private void OverdraftBudgetSumInput(ChangeEventArgs e)
    {
        string budgetInTextBox = e.Value.ToString();
        if (budgetInTextBox.Length > 0)
        {
            budgetSumToMove = Double.Parse(budgetInTextBox);
        }
        else
        {
            budgetSumToMove = currentGap;
        }

        Console.WriteLine(overdraftClass);

        //titleInputLength = titleInput.Length;
    }

    public async Task closeOverdraftWindow()
    {

        var transOverdraftRes = await Http.GetAsync("api/Transactions/updateOverDraftTrans/" + transIDtoEdit); //updates the transType to 3
        if (transOverdraftRes.IsSuccessStatusCode)
        {

            overdraftNotTreated.InvokeAsync(true);

        }
        else
        {
            Console.WriteLine("update trans type failed");

        }

        overdraftDetected = true;

        isTransactionOverlayOpen.InvokeAsync(false);

    }




    public void transOverlayControl()
    {
        isTransactionOverlayOpen.InvokeAsync(false);
    }



    public async Task getAllUserTags()
    {
        isTopDropDownOpen = false;
        isButtomDropDownOpen = !isButtomDropDownOpen;

        if (isButtomDropDownOpen)
        {
            var allTagsRes = await Http.GetAsync("api/Transactions/getAllUserTags/" + userID);
            if (allTagsRes.IsSuccessStatusCode)
            {
                allUserTags = await allTagsRes.Content.ReadFromJsonAsync<List<TagsToShow>>();

                if (allUserTags.Count > 0)
                {
                    foreach (TagsToShow tag in allUserTags)
                    {
                        if (newTransaction.tagID == tag.id)
                        {
                            chosenTag = tag;
                        }
                    }
                }
            }
            else
            {
                Console.WriteLine("No tags found");
            }
        }
    }

    public void ChooseTagForTrans(TagsToShow tag)
    {
        isTagChosen = !isTagChosen;
        //chosenTag = tag;

        if (chosenTag == tag)
        {
            chosenTag = new TagsToShow(); // Unselect the tag

        }
        else
        {
            chosenTag = tag; // Set the new selected tag
        }
    }

    public void tagCreationOverlay()
    {
        createTagOverlay = !createTagOverlay;
        transDisplay = !transDisplay;
        currentTagName = "";
        currentTagColor = "";
        tagNameLength = 0;
        selectedClass = "";
        createdTag = new TagsToShow();

    }

    public async Task tagCreation()
    {
        if (userID > 0 && createdTag.tagTitle != "")
        {
            if (createdTag.tagColor == "" || createdTag.tagColor == null)
            {
                createdTag.tagColor = "#AEA2F9";
            }

            var addTagInDBreq = await Http.PostAsJsonAsync("api/Present/addTag/" + userID, createdTag);
            if (addTagInDBreq.IsSuccessStatusCode)
            {
                int newTagID = addTagInDBreq.Content.ReadFromJsonAsync<int>().Result;
                createdTag.id = newTagID;
                allUserTags.Add(createdTag);
                tagCreationOverlay();
            }
        }
    }

    private void tagTitleLengthCheck(ChangeEventArgs e)
    {
        currentTagName = e.Value.ToString();
        if (currentTagName.Length == 0)
        {
            emptyTagName = true;
        }
        else
        {
            emptyTagName = false;
        }
        tagNameLength = currentTagName.Length;
        createdTag.tagTitle = currentTagName;

    }

    bool isColorClicked = false;
    string selectedClass = "";
    string currentTagColor = "";

    private void UpdateTagColor(string color)
    {
        isColorClicked = true;

        if (selectedClass == color)
        {
            // If the color is already selected, unselect it
            selectedClass = ""; // Reset the selected color
            createdTag.tagColor = ""; // Assuming you want to clear the selected color

        }
        else
        {
            Console.WriteLine(color + "color");
            // Otherwise, update to the new selected color
            currentTagColor = color;
            selectedClass = color;
            createdTag.tagColor = color;
            convertTagColors(color);
        }
    }

    public void convertTagColors(string tagColor)
    {
        Console.WriteLine(tagColor + "tagColor");
        string convertedColor = "";
        string outlineColor = "";
        if (tagColor.Contains('#'))
        {
            selectedClass = tagColor;
        }
        else
        {

            switch (tagColor)
            {
                case "rgba(244, 179, 103, 0.4)": //mustard
                    convertedColor = "rgba(244, 179, 103, 0.13)";
                    outlineColor = "#F4B367";
                    Console.WriteLine("cat color is mustard");
                    break;
                case "rgba(174, 162, 249, 0.4)": //purple
                    convertedColor = "rgba(174, 162, 249, 0.13)";
                    outlineColor = "#AEA2F9";
                    Console.WriteLine("cat color is dark purple");
                    break;
                case "rgba(244, 103, 171, 0.4)": //dark pink
                    convertedColor = "rgba(244, 103, 171, 0.13)";
                    outlineColor = "#F467AB";
                    Console.WriteLine("cat color is dark pink");
                    break;
                case "rgba(244, 120, 103, 0.4)": //salmon pink
                    convertedColor = "rgba(244, 120, 103, 0.13)";
                    outlineColor = "#F47867";
                    Console.WriteLine("cat color is salmon pink");
                    break;
                case "rgba(103, 142, 244, 0.4)": //defualt
                    convertedColor = "rgba(103, 142, 244, 0.13)";
                    outlineColor = "#678EF4";
                    Console.WriteLine("cat color is default");
                    break;
                case "rgba(141, 228, 191, 0.4)": //light green
                    convertedColor = "rgba(141, 228, 191, 0.13)";
                    outlineColor = "#8DE4BF";
                    Console.WriteLine("cat color is light green");
                    break;
                case "rgba(103, 202, 244, 0.4)": //light blue
                    convertedColor = "rgba(103, 202, 244, 0.13)";
                    outlineColor = "#67CAF4";
                    Console.WriteLine("cat color is light blue");
                    break;
                case "rgba(255, 239, 157, 0.4)": //banana
                    convertedColor = "rgba(255, 239, 157, 0.13)";
                    outlineColor = "#FCE884";
                    Console.WriteLine("cat color is banana");
                    break;
                case "rgba(249, 211, 194, 0.4)": //cream
                    convertedColor = "rgba(249, 211, 194, 0.13)";
                    outlineColor = "#F9D3C2";
                    Console.WriteLine("cat color is cream");
                    break;
                case "rgba(9, 174, 115, 0.4)": //dark green
                    convertedColor = "rgba(9, 174, 115, 0.13)";
                    outlineColor = "#09AE73";
                    Console.WriteLine("cat color is dark green");
                    break;
                case "rgba(140, 139, 139, 0.4)": //dark gray
                    convertedColor = "rgba(140, 139, 139, 0.25)";
                    outlineColor = "#8C8B8B";
                    Console.WriteLine("cat color is dark gray");
                    break;
                case "rgba(218, 218, 218, 0.4)": //gray
                    convertedColor = "rgba(218, 218, 218, 0.13)";
                    outlineColor = "#DADADA";
                    Console.WriteLine("cat color is light gray");
                    break;
                default:
                    convertedColor = "rgba(103, 142, 244, 0.13)";
                    outlineColor = "#AEA2F9";
                    Console.WriteLine("cat color is default");
                    break;
            };

            selectedClass = outlineColor;


        }


        Console.WriteLine(selectedClass + "צבע תגית");
        //isTagColor = false;
    }


    private DateTime parsedDate;
    private bool attemptedParsing = false;
    /// <summary>
    /// holds the fixedMonthly children between edits in the overlay
    /// </summary>
    List<TransactionToAdd> potentialFixedChildren = new List<TransactionToAdd>();

    /// <summary>
    /// creates the fixed monthly input overlay
    /// </summary>
    public async Task repeatingTransOverlay()
    {
        Console.WriteLine("repeatingTransOverlay clicked");
        isReapetedBtnClicked = true;
        resetMonthValues = false;

        // gets the existing children in DB, if they aren't alreaedy in the page:
        if (transIDtoEdit > 0 && reapeatedTransValuesList.Count <= 0)
        {

            var repeatedTransValuesRes = await Http.GetAsync("api/Transactions/getRepeatedTransToEdit/" + transIDtoEdit);

            if (repeatedTransValuesRes.IsSuccessStatusCode)
            {
                reapeatedTransValuesList = repeatedTransValuesRes.Content.ReadFromJsonAsync<List<RepeatedTransToShow>>().Result;
                if (reapeatedTransValuesList.Count > 0)
                {
                    newTransaction.fixedMonthly = true;
                }
                else
                {
                    newTransaction.fixedMonthly = false;
                }
            }
            else
            {
                Console.WriteLine("finding repeated Trans values failed");
            }
        }

        if (fixedTransChildrenToAdd == null || fixedTransChildrenToAdd.Count <= 0)
        {

            int currentDay = newTransaction.transDate.Day;
            int currentYear = newTransaction.transDate.Year;


            if (potentialFixedChildren == null || potentialFixedChildren.Count <= 0) //means the user clicked the fixedMonthly btn for the 1st time
            {

                foreach (string m in months)
                {

                    string dateString = $"{currentDay} {m} {currentYear}";
                    DateTime tempDate;
                    if (DateTime.TryParseExact(dateString, "d MMMM yyyy", CultureInfo.InvariantCulture, DateTimeStyles.None, out tempDate))
                    {
                        parsedDate = checkDateExistsInMonth(tempDate, tempDate.Month);

                    }
                    else
                    {
                        Console.WriteLine("date parsing failed");
                        DateTime month = DateTime.ParseExact(m, "MMMM", System.Globalization.CultureInfo.InvariantCulture);
                        int monthNumber = month.Month;
                        parsedDate = checkDateExistsInMonth(newTransaction.transDate, monthNumber);
                    }
                    attemptedParsing = true;

                    //means the transaction is fixedMonthly=true in DB:
                    if (reapeatedTransValuesList.Count > 0)
                    {
                        Console.WriteLine("reapeatedTransValuesList count- " + reapeatedTransValuesList.Count);

                        TransactionToAdd childTrans = new TransactionToAdd()
                            {
                                transValue = newTransaction.transValue,
                                valueType = newTransaction.valueType,
                                description = newTransaction.description,
                                fixedMonthly = false,
                                splitPayment = false,
                                parentTransID = newTransaction.parentTransID,
                                tagID = newTransaction.tagID,
                                tagTitle = newTransaction.tagTitle,
                                tagColor = newTransaction.tagColor,
                                transTitle = newTransaction.transTitle,
                                subCategoryID = subCategoryIDTOGet,
                                transDate = parsedDate,
                                transType = newTransaction.transType
                            };
                        if (!categoryTypeIndicator)
                        {
                            childTrans.transType = 1; //expense
                        }
                        else
                        {
                            childTrans.transType = 2; //income
                        }

                        var matchingTrans = reapeatedTransValuesList.FirstOrDefault(t => t.transDate == tempDate); //searches for the trans in the list that fits the current trans
                        if (matchingTrans != null) //if the childTrans exists in DB
                        {
                            childTrans.transValue = matchingTrans.transValue;
                            childTrans.parentTransID = matchingTrans.id;
                        }

                        fixedTransChildrenToAdd.Add(childTrans);
                        potentialFixedChildren.Add(childTrans);

                        Console.WriteLine("childTrans.transValue- " + childTrans.transValue);
                    }
                    else //if the trans wasn't fixedMonthly before
                    {
                        TransactionToAdd childTrans = new TransactionToAdd()
                            {
                                transValue = newTransaction.transValue,
                                valueType = newTransaction.valueType,
                                description = newTransaction.description,
                                fixedMonthly = false,
                                splitPayment = false,
                                parentTransID = newTransaction.parentTransID,
                                tagID = newTransaction.tagID,
                                tagTitle = newTransaction.tagTitle,
                                tagColor = newTransaction.tagColor,
                                transTitle = newTransaction.transTitle,
                                subCategoryID = subCategoryIDTOGet,
                                transDate = parsedDate,
                                transType = newTransaction.transType
                            };
                        if (!categoryTypeIndicator)
                        {
                            childTrans.transType = 1; //expense
                        }
                        else
                        {
                            childTrans.transType = 2; //income
                        }

                        fixedTransChildrenToAdd.Add(childTrans);
                        potentialFixedChildren.Add(childTrans);
                    }
                }

            }
        }

        //newTransaction.fixedMonthly = true;
        hiddenReOverlay = "";
        returningTrans = !returningTrans; //opens the overlay

    }

    /// <summary>
    /// saving repeating transactions when the parent is fixedMonthly and was created now
    /// </summary>

    public async Task saveRepeatedTransactions(int parentTransID)
    {
        fixedTransChildrenToAdd.RemoveAll(e => e.transDate <= newTransaction.transDate); //deletes all children that their date had already passed
        for (int i = fixedTransChildrenToAdd.Count - 1; i >= 0; i--)
        {
            TransactionToAdd repT = fixedTransChildrenToAdd[i];
            if (repT.transValue > 0)
            {
                repT.parentTransID = parentTransID;
                repT.tagID = newTransaction.tagID;
                repT.tagColor = newTransaction.tagColor;
                repT.tagTitle = newTransaction.tagTitle;
                repT.fixedMonthly = false;
                repT.splitPayment = false;
            }

            if (fixedTransChildrenToAdd[i].transValue <= 0 || fixedTransChildrenToAdd[i].transValue == null)
            {
                fixedTransChildrenToAdd.RemoveAt(i);
            }

        }

        foreach (TransactionToAdd repT in fixedTransChildrenToAdd)
        {
            var transToSaveRes = await Http.PostAsJsonAsync("api/Transactions/AddTransaction", repT);
            if (transToSaveRes.IsSuccessStatusCode)
            {
                Console.WriteLine("ההזנה של תאריך " + repT.transDate + " נקלטה בהצלחה, שערכה הוא " + repT.transValue);
            }
            else
            {
                Console.WriteLine("הזנה נכשלה- " + repT.transDate);
            }
        }
        Console.WriteLine("fixedTransChildrenToAdd count- " + fixedTransChildrenToAdd.Count);
        fixedTransChildrenToAdd = new List<TransactionToAdd>();
    }

    /// <summary>
    /// updating repeating transactions when the parent is fixedMonthly
    /// </summary>
    public async Task updateReTransactions(List<RepeatedTransToShow> reTransToUpdate)
    {
        reTransToUpdate.RemoveAll(e => e.transDate <= newTransaction.transDate); //removes all transaction that don't occur in the future (including the present trans)
        if (newTransaction.fixedMonthly == true)
        {
            foreach (RepeatedTransToShow childTrans in reTransToUpdate)
            {
                if ((childTrans.id > 0 && childTrans.transValue <= 0) || (childTrans.id > 0 && childTrans.transValue.ToString() == "") || (childTrans.id > 0 && childTrans.transValue == null)) //deletes the child if it exists in DB and doesn't have an appropriate value
                {

                    var deleteRes = await Http.DeleteAsync("api/Transactions/deleteTransaction/" + childTrans.id);
                    if (deleteRes.IsSuccessStatusCode)
                    {
                        Console.WriteLine("הזנה חוזרת ריקה נמחקה בהצלחה");
                    }
                    else
                    {
                        Console.WriteLine("בעיה במחיקת הזנה חוזרת ריקה");
                    }


                }
                else if ((childTrans.id == 0 && childTrans.transValue > 0) || (childTrans.id == null && childTrans.transValue > 0)) //adds the child if it doesn't exist yet
                {

                    TransactionToAdd newRepeatedT = new TransactionToAdd()
                        {
                            transTitle = newTransaction.transTitle,
                            subCategoryID = newTransaction.subCategoryID,
                            transType = newTransaction.transType,
                            transValue = childTrans.transValue,
                            valueType = newTransaction.valueType,
                            transDate = checkDateExistsInMonth(childTrans.transDate, childTrans.transDate.Month),
                            description = newTransaction.description,
                            parentTransID = transIDtoEdit,
                            fixedMonthly = false,
                            splitPayment = false

                        };
                    var transToSaveRes = await Http.PostAsJsonAsync("api/Transactions/AddTransaction", newRepeatedT);
                    if (transToSaveRes.IsSuccessStatusCode)
                    {
                        Console.WriteLine("נוספה הוצאה חוזרת בהצלחה");
                    }
                    else
                    {
                        Console.WriteLine("נכשלה הוספה של הוצאה חוזרת ");
                    }
                }
                else if (childTrans.id > 0 && childTrans.transValue > 0)//updates the child if it already exists
                {
                    var TransactionsToSaveRes = await Http.PostAsJsonAsync("api/Transactions/UpdateRepeatedTrans", childTrans);
                    if (TransactionsToSaveRes.IsSuccessStatusCode)
                    {
                        Console.WriteLine("הזנה חוזרת עודכנה בהצלחה");
                    }
                    else
                    {
                        Console.WriteLine("עדכון הוצאה חוזרת נכשל");
                    }
                }
            }
        }
        else //if the transaction was turned fixedMonthly=false
        {
            var deleteSplitChildren = await Http.DeleteAsync("api/Transactions/deleteSplittedChildrenOnly/" + transIDtoEdit);
            if (deleteSplitChildren.IsSuccessStatusCode)
            {
                Console.WriteLine("כל החזרות של הזנה זו נמחקו בהצלחה");
            }
            else
            {
                Console.WriteLine("נכשלה המחיקה של כל החזרות של הזנה זו");
            }
        }


    }

    public void undoFixedMonthly()
    {
        //isRepeatedTrans = false;
        newTransaction.fixedMonthly = false;


        fixedTransChildrenToAdd = new List<TransactionToAdd>();
        Console.WriteLine("fixedTransChildrenToAdd count- " + fixedTransChildrenToAdd.Count);

        if (categoryTypeIndicator)
        {
            repeatedBtnTitle = "הגדרת ההכנסה כחוזרת";
        }
        else
        {
            repeatedBtnTitle = "הגדרת ההוצאה כחוזרת";
        }

        //closes the fixed trans overlay
        returningTrans = false;
        isReapetedBtnClicked = false;
        hiddenReOverlay = "";

        //enables both buttons in the trans form:
        fixedMonthly = false;
        splitPayment = false;


    }

    //-------------------------------------//
    public async Task getStreakDetails()
    {
        if (userID > 0)
        {
            var streakDataRes = await Http.GetAsync("api/Present/checkCurrentStreak/" + userID); //checking streak by week amount and tran count
            if (streakDataRes.IsSuccessStatusCode)
            {
                List<TransAmountByWeekToShow> transCountByWeeksList = new List<TransAmountByWeekToShow>();
                transCountByWeeksList = streakDataRes.Content.ReadFromJsonAsync<List<TransAmountByWeekToShow>>().Result;

                currentStreak = 0;
                foreach (TransAmountByWeekToShow week in transCountByWeeksList)
                {
                    if (week.transactionCount >= 3)
                    {
                        currentStreak++;
                    }
                }

                if (currentStreak > 0)
                {
                    string streakStatus = streakStatusCheck(currentStreak); //streak in page
                    List<string> streakStatusOpt = new List<string>()
    {
    "מטבע ארד", "מטבע כסף", "מטבע זהב", "שטר", "שטרות","גביע","יהלום"
    };

                    var getCurrentStatRes = await Http.GetAsync("api/Present/getUserStreakStatus/" + userID);
                    if (getCurrentStatRes.IsSuccessStatusCode)
                    {
                        string getCurrentStat = await getCurrentStatRes.Content.ReadAsStringAsync(); //streak in DB
                        if (streakStatusOpt.Contains(getCurrentStat))
                        {
                            int statInDB = streakStatusOpt.IndexOf(getCurrentStat);
                            int newerStat = streakStatusOpt.IndexOf(streakStatus);


                            if (newerStat > statInDB)
                            {
                                //take the new status
                                streakStatus = streakStatusOpt[newerStat];

                                var updateStreak = await Http.GetAsync("api/Present/updateStreakStat/" + userID + "/" + streakStatus);
                                if (updateStreak.IsSuccessStatusCode)
                                {
                                    //open new status pop up
                                    Console.WriteLine("streak status updated, new status is: " + streakStatus);
                                    updatedStreak.InvokeAsync(streakStatus);
                                }
                                else
                                {
                                    Console.WriteLine("failed to update streak status, status remains the same and is: " + streakStatus);
                                }
                            }
                        }
                        else if (getCurrentStat == null || getCurrentStat == "")
                        {
                            //take the new status
                            streakStatus = null;

                            var updateStreak = await Http.GetAsync("api/Present/updateStreakStat/" + userID + "/" + streakStatus);
                            if (updateStreak.IsSuccessStatusCode)
                            {
                                //open new status pop up
                                Console.WriteLine("streak status updated, new status is null");
                                updatedStreak.InvokeAsync(streakStatus);
                            }
                            else
                            {
                                Console.WriteLine("failed to update streak status, status remains the same and is: " + streakStatus);
                            }
                        }
                    }

                    Console.WriteLine("streak status- " + streakStatus + ", week amount- " + currentStreak);
                }
            }
        }
    }

    public string streakStatusCheck(int weekAmount)
    {
        if (weekAmount <= 1 && weekAmount < 2)
        {
            return "מטבע ארד";
        }
        else if (weekAmount > 2 && weekAmount <= 9)
        {

            return "מטבע כסף";
        }
        else if (weekAmount > 9 && weekAmount <= 12)
        {

            return "מטבע זהב";
        }
        else if (weekAmount > 12 && weekAmount <= 20)
        {

            return "שטר";
        }
        else if (weekAmount > 20 && weekAmount <= 24)
        {

            return "שטרות";
        }
        else if (weekAmount >= 32)
        {

            return "גביע";
        }
        else if (weekAmount > 32)
        {

            return "יהלום";
        }
        else
        {
            return "";
        }
    }

    //-------------------------------------//


    void manageDropDown()
    {
        isTopDropDownOpen = !isTopDropDownOpen;
        isButtomDropDownOpen = false;
    }

    private void TransTitleLengthCounter(ChangeEventArgs e)
    {
        isTyped = true;
        titleInput = e.Value.ToString();
        newTransaction.transTitle = titleInput;
        titleInputLength = titleInput.Length;
    }

    int descLength = 0;

    private void TransDescLengthCounter(ChangeEventArgs e)
    {
        string description = "";
        description = e.Value.ToString();
        descriptionInput = description;
        newTransaction.description = description;
        descLength = description.Length;
    }

    bool topExpBubbleOpen = false;
    bool odExpBubble = false;
    bool bottomExpBubbleOpen = false;
    string elementToExp = "";
    string styleAdjustment = "";

    public void expBubbleToolTip(string elementName)
    {
        elementToExp = elementName;

        if (elementName == "Trans")
        {
            topExpBubbleOpen = !topExpBubbleOpen;
            bottomExpBubbleOpen = false;
            odExpBubble = false;
        }
        else if (elementName == "TransTag")
        {
            bottomExpBubbleOpen = !bottomExpBubbleOpen;
            topExpBubbleOpen = false;
            odExpBubble = false;
        }
        else if (elementName == "ODwithNoSubCats" || elementName == "ODwithSubCats")
        {
            odExpBubble = !odExpBubble;
            topExpBubbleOpen = false;
            bottomExpBubbleOpen = false;
        }

    }

    public void closeExpOverlay()
    {
        topExpBubbleOpen = false;
    }

    private void transAmount(ChangeEventArgs e)
    {

        string transSumInput = e.Value.ToString();

        if (transSumInput.Length == 0)
        {
            isTransSumTyped = true;
        }
        else
        {
            isTransSumTyped = false;
        }

    }
}
